<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Dynamic</title>
    
    <!-- CSS Libraries -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    
    <!-- Custom Styles -->
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Sarabun', sans-serif;
            color: #343a40;
        }
        .upload-container {
            max-width: 700px; margin: 5rem auto; padding: 2.5rem;
            background-color: #ffffff; border-radius: 1rem;
            box-shadow: 0 8px 25px rgba(0,0,0,.07);
            text-align: center; border: 1px solid #dee2e6;
        }
        .card {
            border: none;
            box-shadow: 0 8px 25px rgba(0,0,0,.05);
            border-radius: 1rem; height: 100%;
        }
        .card-header {
            background: linear-gradient(to right, #007bff, #0056b3);
            color: white; font-weight: bold; border-top-left-radius: 1rem;
            border-top-right-radius: 1rem; border-bottom: none; padding: 1rem 1.5rem;
        }
        .kpi-card .card-body { transition: transform 0.2s, box-shadow 0.2s; }
        .kpi-card:hover .card-body { transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,.1); }
        .chart-container { position: relative; width: 100%; }
        .form-select:focus, .form-control:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.25rem rgba(0, 123, 255, 0.25);
        }
        .sortable-header { cursor: pointer; user-select: none; }
        .sortable-header:hover { background-color: #e9ecef; }
        .sort-asc::after { content: ' ▲'; font-size: 0.8em; }
        .sort-desc::after { content: ' ▼'; font-size: 0.8em; }
        .filter-row {
            background-color: #f1f3f5;
            border-radius: 0.5rem;
        }
        .header-select-list, #sheet-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .border-dashed {
            border: 2px dashed #dee2e6 !important;
        }
        .template-card {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
        }
        .template-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,.1);
            border-color: #007bff !important;
        }
        .chart-preview-container {
            height: 150px;
            position: relative;
        }
        
        /* Excel-like table styling */
        .table {
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            font-family: 'Sarabun', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .table th, .table td {
            border: 1px solid #d0d7de;
            padding: 6px 12px;
            margin: 0;
            line-height: 1.4;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
            min-width: 100px;
        }
        
        .table th {
            background: linear-gradient(to bottom, #f8f9fa 0%, #e9ecef 100%);
            font-weight: 600;
            border-bottom: 2px solid #d0d7de;
            position: sticky;
            top: 0;
            z-index: 10;
            text-align: center;
            color: #495057;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .table tbody tr {
            transition: background-color 0.15s ease;
        }
        
        .table tbody tr:hover {
            background-color: #f1f8ff !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .table tbody tr:nth-child(even) {
            background-color: #fafbfc;
        }
        
        .table tbody tr:nth-child(odd) {
            background-color: #ffffff;
        }
        
        .table-responsive {
            border: 1px solid #d0d7de;
            border-radius: 8px;
            overflow: auto;
            max-height: 600px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        /* Excel number formatting */
        .excel-number {
            text-align: right;
            font-family: 'SF Mono', Consolas, Monaco, 'Lucida Console', monospace;
            font-variant-numeric: tabular-nums;
            color: #0969da;
        }
        
        .excel-date {
            text-align: center;
            color: #8250df;
        }
        
        .excel-text {
            text-align: left;
            color: #24292f;
        }
        
        /* Sort indicators */
        .sortable-header:hover {
            background: linear-gradient(to bottom, #e9ecef 0%, #dee2e6 100%) !important;
            transform: translateY(-1px);
        }
        
        .sort-asc::after {
            content: ' ▲';
            font-size: 0.8em;
            color: #0969da;
            margin-left: 4px;
        }
        
        .sort-desc::after {
            content: ' ▼';
            font-size: 0.8em;
            color: #0969da;
            margin-left: 4px;
        }
        
        /* Cell animations */
        .table td {
            transition: all 0.2s ease;
        }
        
        .table td:hover {
            background-color: #f1f8ff;
            transform: scale(1.02);
            z-index: 5;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>

    <div class="container-fluid p-4">
        
        <!-- Upload View -->
        <div id="upload-view">
            <div class="upload-container">
                <h1 class="mb-3">Dashboard Dynamic</h1>
                <p class="text-muted">โปรดอัปโหลดไฟล์ Excel (.xlsx, .xls) เพื่อเริ่มต้นการวิเคราะห์</p>
                <hr class="my-4">
                <input type="file" id="excel-input" class="form-control form-control-lg" accept=".xlsx, .xls, .csv">
                <div id="loading-spinner" class="text-center mt-4" style="display: none;">
                    <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
                    <p class="mt-2" id="loading-status">กำลังประมวลผลไฟล์...</p>
                </div>
                <div id="upload-error" class="text-danger mt-3"></div>
            </div>
        </div>

        <!-- Dashboard View -->
        <div id="dashboard-view" class="d-none">
            <div id="pdf-export-area">
                <header class="mb-4 d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3">
                    <div>
                        <h1 class="mb-0">ผลการวิเคราะห์</h1>
                        <!-- Sheet switcher will be placed here -->
                        <div id="sheet-switcher-container" class="mt-2"></div>
                        <p id="file-info" class="text-muted small mt-1">ภาพรวมข้อมูลจากไฟล์ของคุณ</p>
                    </div>
                    <div class="d-flex gap-2 flex-wrap justify-content-end" id="dashboard-actions">
                        <button id="create-kpi-btn" class="btn btn-info text-white"><i class="bi bi-calculator-fill me-2"></i>สร้าง KPI</button>
                        <button id="create-chart-btn" class="btn btn-primary"><i class="bi bi-plus-circle-dotted me-2"></i>สร้างกราฟ</button>
                        
                        <div class="dropdown">
                            <button class="btn btn-secondary dropdown-toggle" type="button" id="settingsMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="bi bi-gear-fill me-1"></i> ตั้งค่า
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="settingsMenuButton">
                                <li><a class="dropdown-item" href="#" id="save-config-btn"><i class="bi bi-download me-2"></i>บันทึกการตั้งค่า (ไฟล์)</a></li>
                                <li><a class="dropdown-item" href="#" id="load-config-btn"><i class="bi bi-upload me-2"></i>นำเข้าการตั้งค่า (ไฟล์)</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" id="export-csv-btn"><i class="bi bi-file-earmark-spreadsheet-fill me-2"></i>ส่งออกเป็น CSV</a></li>
                                <li><a class="dropdown-item" href="#" id="export-pdf-btn"><i class="bi bi-file-earmark-pdf-fill me-2"></i>ส่งออกเป็น PDF</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item text-danger" href="#" id="clear-storage-btn"><i class="bi bi-trash3-fill me-2"></i>ล้างค่าที่บันทึกไว้ (ในเครื่อง)</a></li>
                            </ul>
                        </div>
                        <input type="file" id="load-config-input" class="d-none" accept=".json">

                        <button id="upload-new-button" class="btn btn-outline-secondary"><i class="bi bi-arrow-clockwise me-2"></i>อัปโหลดไฟล์ใหม่</button>
                    </div>
                </header>

                <!-- KPIs Section -->
                <div id="kpis-container" class="row mb-4">
                     <div id="no-kpis-placeholder" class="col-12 text-center text-muted py-4">
                        <div class="card p-4 bg-light border-dashed">
                            <i class="bi bi-calculator fs-1"></i>
                            <h5 class="mt-3">ยังไม่มี KPI</h5>
                            <p class="mb-0">คลิกที่ปุ่ม "สร้าง KPI" เพื่อเพิ่มการ์ดชี้วัด</p>
                        </div>
                    </div>
                </div>

                <!-- Charts Section -->
                <div id="charts-container" class="row mb-4">
                     <div id="no-charts-placeholder" class="col-12 text-center text-muted py-4">
                        <div class="card p-4 bg-light border-dashed">
                            <i class="bi bi-bar-chart-line fs-1"></i>
                            <h5 class="mt-3">ยังไม่มีกราฟ</h5>
                            <p class="mb-0">คลิกที่ปุ่ม "สร้างกราฟ" เพื่อเริ่มสร้างการแสดงผลข้อมูลของคุณ</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Filter & Data Table Section -->
            <div class="card">
                <div class="card-body p-4">
                    <h5 class="card-title mb-3">ตัวกรองข้อมูล (Filters)</h5>
                    <div id="filter-builder-container" class="mb-4">
                        <!-- Dynamic filters will be added here -->
                    </div>
                    <button id="add-filter-btn" class="btn btn-outline-primary btn-sm"><i class="bi bi-plus-lg me-1"></i> เพิ่มฟิลเตอร์</button>
                    <hr>
                    <h5 class="card-title mb-3">ตารางข้อมูล</h5>
                    
                    <!-- Table Controls -->
                    <div class="d-flex justify-content-between align-items-center mb-3 flex-column flex-md-row gap-3">
                        <div class="d-flex align-items-center gap-2">
                            <label for="rows-per-page-select" class="col-form-label col-form-label-sm">แสดง</label>
                            <select id="rows-per-page-select" class="form-select form-select-sm" style="width: 75px;">
                                <option value="15" selected>15</option>
                                <option value="25">25</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                            </select>
                            <span class="col-form-label col-form-label-sm">รายการ</span>
                        </div>
                        <div id="pagination-controls"></div>
                    </div>

                    <div class="table-responsive">
                        <table class="table table-striped table-hover">
                            <thead id="data-table-header"></thead>
                            <tbody id="data-table-body"></tbody>
                        </table>
                        <div id="no-results" class="text-center py-5 text-muted d-none"><p>ไม่พบข้อมูลที่ตรงกับเงื่อนไข</p></div>
                    </div>
                </div>
            </div>
            
            <footer class="text-center text-sm text-muted mt-5"><p id="footer-text">Chatrium© 2024</p></footer>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal fade" id="sheet-select-modal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header"><h5 class="modal-title">เลือกชีตที่จะนำมาวิเคราะห์</h5></div>
          <div class="modal-body">
            <p class="text-muted">ไฟล์ Excel ของคุณมีหลายชีต กรุณาเลือกชีตที่ต้องการ (สามารถเลือกได้หลายชีต)</p>
            <div id="sheet-list" class="list-group">
                <!-- Checkboxes will be injected here -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" id="process-selected-sheets-btn">ดำเนินการต่อ</button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal fade" id="template-select-modal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">เลือกรูปแบบการวิเคราะห์ (Template)</h5>
          </div>
          <div class="modal-body">
            <p class="text-muted">เราได้วิเคราะห์ข้อมูลของคุณและสร้างเทมเพลตเริ่มต้นให้เลือก หรือคุณสามารถเลือก "เริ่มต้นจากศูนย์" เพื่อตั้งค่าเองทั้งหมด</p>
            <div id="template-card-container" class="row g-3 mt-2">
                <!-- Template cards will be injected here by JavaScript -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-outline-secondary" id="start-from-scratch-button">
                <i class="bi bi-tools me-2"></i>เริ่มต้นจากศูนย์ (ตั้งค่าเอง)
            </button>
          </div>
        </div>
      </div>
    </div>


    <!-- New Multi-Sheet Header Configuration Modal -->
    <div class="modal fade" id="header-config-modal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="header-config-modal-title">ตั้งค่าคอลัมน์</h5>
          </div>
          <div class="modal-body">
            <p class="text-muted">กรุณาเลือกคอลัมน์ที่ต้องการใช้งานสำหรับชีตนี้</p>
            <div id="header-config-list" class="list-group header-select-list">
                <!-- Header checkboxes will be injected here -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" id="next-header-config-btn">Next Sheet</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="kpi-modal" tabindex="-1" aria-labelledby="kpiModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header"><h5 class="modal-title" id="kpiModalLabel">สร้าง KPI ใหม่</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div>
                <div class="modal-body">
                    <form id="create-kpi-form">
                        <div class="mb-3"><label for="kpi-title" class="form-label">ชื่อ KPI</label><input type="text" class="form-control" id="kpi-title" required></div>
                        <div class="mb-3"><label for="kpi-calculation" class="form-label">วิธีการคำนวณ</label><select class="form-select" id="kpi-calculation" required></select></div>
                        <div class="mb-3" id="kpi-column-container"><label for="kpi-column" class="form-label">เลือกคอลัมน์</label><select class="form-select" id="kpi-column" required></select></div>
                    </form>
                </div>
                <div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ปิด</button><button type="button" class="btn btn-primary" id="save-kpi-button">บันทึก KPI</button></div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="create-chart-modal" tabindex="-1" aria-labelledby="createChartModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header"><h5 class="modal-title" id="createChartModalLabel">สร้างกราฟใหม่</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div>
          <div class="modal-body">
            <form id="create-chart-form">
              <div class="mb-3"><label for="chart-title" class="form-label">ชื่อกราฟ</label><input type="text" class="form-control" id="chart-title" required></div>
              <div class="mb-3"><label for="chart-type" class="form-label">ประเภทกราฟ</label><select class="form-select" id="chart-type"><option value="bar">กราฟแท่ง (Bar)</option><option value="pie">กราฟวงกลม (Pie)</option><option value="doughnut">กราฟโดนัท (Doughnut)</option><option value="line">กราฟเส้น (Line)</option></select></div>
              <div class="mb-3"><label for="chart-group-by" class="form-label">จัดกลุ่มข้อมูลด้วย (Group By)</label><select class="form-select" id="chart-group-by" required></select></div>
              <div class="mb-3"><label for="chart-metric" class="form-label">ค่าที่ต้องการวัด (Measure)</label><select class="form-select" id="chart-metric" required></select></div>
              <div class="mb-3" id="metric-aggregation-container"><label for="chart-metric-aggregation" class="form-label">วิธีการคำนวณ</label><select class="form-select" id="chart-metric-aggregation"><option value="sum">ผลรวม (Sum)</option><option value="average">ค่าเฉลี่ย (Average)</option></select></div>
            </form>
          </div>
          <div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ปิด</button><button type="button" class="btn btn-primary" id="save-chart-button">บันทึกกราฟ</button></div>
        </div>
      </div>
    </div>


    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/parn-pon/thaifont-jspdf/Sarabun-Regular-normal.js"></script>


    <!-- Main Application Script -->
    <script>
        // --- GLOBAL STATE ---
        let fullOriginalData = [];
        let originalData = [];
        let filteredData = [];
        let allHeaders = [];
        let headers = [];
        let numericHeaders = [];
        let activeFilters = [];
        let userKPIs = [];
        let userCharts = [];
        let chartInstances = {};
        let workbook;
        let workbookDataStore = {};
        let currentFileName = '';
        let currentSheetName = '';
        let currentPage = 1;
        let rowsPerPage = 15;
        let sortKey = '';
        let sortDir = 'asc';
        
        let sheetSelectModal, headerConfigModal, kpiModal, createChartModal, templateSelectModal;
        
        // --- State for Header Configuration Flow ---
        let sheetsToConfigure = [];
        let currentConfigSheetIndex = 0;


        // --- DOM ELEMENTS ---
        const getEl = (id) => document.getElementById(id);
        const uploadView = getEl('upload-view');
        const dashboardView = getEl('dashboard-view');
        const excelInput = getEl('excel-input');
        const loadingSpinner = getEl('loading-spinner');
        const loadingStatusEl = getEl('loading-status');
        const uploadErrorEl = getEl('upload-error');
        const fileInfoEl = getEl('file-info');
        const sheetList = getEl('sheet-list');
        const tableHeaderEl = getEl('data-table-header');
        const tableBodyEl = getEl('data-table-body');
        const noResultsEl = getEl('no-results');
        const paginationControls = getEl('pagination-controls');
        const filterBuilderContainer = getEl('filter-builder-container');
        const kpisContainer = getEl('kpis-container');
        const noKpisPlaceholder = getEl('no-kpis-placeholder');
        const chartsContainer = getEl('charts-container');
        const noChartsPlaceholder = getEl('no-charts-placeholder');

        // --- FILE & DATA LOADING ---

        function handleFileSelection(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                // Validate file type
                if (!file.name.match(/\.(xlsx?|csv)$/i)) {
                    uploadErrorEl.textContent = "กรุณาเลือกไฟล์ Excel (.xlsx, .xls) หรือ CSV เท่านั้น";
                    return;
                }
                
                // Validate file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    uploadErrorEl.textContent = "ไฟล์มีขนาดใหญ่เกินไป (สูงสุด 10MB)";
                    return;
                }
                
                currentFileName = file.name;
                loadingSpinner.style.display = 'block';
                uploadErrorEl.textContent = '';
                loadingStatusEl.textContent = 'กำลังอ่านไฟล์...';
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                         setTimeout(() => {
                            try {
                                workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array', cellDates: false });
                                
                                if (!workbook || !workbook.SheetNames || workbook.SheetNames.length === 0) {
                                    throw new Error("ไฟล์ไม่มีชีตข้อมูลหรือไฟล์เสียหาย");
                                }

                                if (workbook.SheetNames.length === 1) {
                                    processAndStoreSheets([workbook.SheetNames[0]]);
                                } else {
                                    const sheetListContainer = getEl('sheet-list');
                                    sheetListContainer.innerHTML = '';
                                    workbook.SheetNames.forEach(name => {
                                        const item = document.createElement('label');
                                        item.className = 'list-group-item';
                                        item.innerHTML = `<input class="form-check-input me-2" type="checkbox" value="${name}" checked> ${name}`;
                                        sheetListContainer.appendChild(item);
                                    });
                                    loadingSpinner.style.display = 'none';
                                    sheetSelectModal.show();
                                }
                            } catch (error) {
                                uploadErrorEl.textContent = "เกิดข้อผิดพลาดในการอ่านไฟล์: " + error.message;
                                loadingSpinner.style.display = 'none';
                            }
                        }, 10);
                    } catch (error) {
                        uploadErrorEl.textContent = "เกิดข้อผิดพลาดในการประมวลผลไฟล์: " + error.message;
                        loadingSpinner.style.display = 'none';
                    }
                };
                reader.onerror = () => { 
                    uploadErrorEl.textContent = "ไม่สามารถอ่านไฟล์ได้ กรุณาตรวจสอบไฟล์และลองใหม่"; 
                    loadingSpinner.style.display = 'none';
                };
                reader.readAsArrayBuffer(file);
                excelInput.value = '';
            } catch (error) {
                uploadErrorEl.textContent = "เกิดข้อผิดพลาดในการเลือกไฟล์: " + error.message;
                loadingSpinner.style.display = 'none';
            }
        }

        /**
         * Parses a sheet with a complex, multi-level HR report structure.
         * @param {Array<Array<any>>} sheetData - Raw data from the sheet.
         * @param {string|null} fileYear - The year extracted from the filename, for defaulting.
         * @returns {{data: Array<Object>, headers: Array<string>}} - The parsed flat data and its headers.
         */
        function parseHrReportData(sheetData, fileYear = null) {
            try {
                if (!sheetData || !Array.isArray(sheetData) || sheetData.length === 0) {
                    throw new Error("ข้อมูลชีตไม่ถูกต้องหรือว่างเปล่า");
                }

                const structuredData = [];
                const finalHeaders = ['department', 'hotel', 'type', 'period', 'value'];

                // --- Constants for identifying rows and columns ---
                const HOTEL_CODES = ['CHRB', 'CRRB', 'CRST', 'ES', 'CGB', 'MHSC', 'MHRB', 'MMSB', 'SDAO', 'LKYT', 'CHRY', 'CNSJ', 'CHH'];
                const EMPLOYMENT_TYPES = ['FT', 'CT', 'OS'];
                const STAFFING_DEPARTMENTS = ['FO', 'HKP', 'Laundry', 'Fitness', 'F&B Service', 'Kitchen', 'A&G', 'Finance', 'Procurement', 'IT', 'HR', 'Security', 'Sales', 'Engineering', 'MarComm', 'E-Commerce', 'Commercial', 'Service Quality Assurance', 'Golf Operations', 'Golf Maintenance'];
                const STAFFING_DEPARTMENT_SET = new Set(STAFFING_DEPARTMENTS.map(dept => dept.toUpperCase()));

                let hotelRowIndex = -1, typeRowIndex = -1, periodRowIndex = -1;
                const upperHotelCodes = HOTEL_CODES.map(c => c.toUpperCase());

                // --- Find the key header rows ---
                const searchLimit = Math.min(sheetData.length, 20);
                for (let i = 0; i < searchLimit; i++) {
                    try {
                        const row = sheetData[i] || [];
                        if (hotelRowIndex === -1 && row.some(cell => upperHotelCodes.includes(String(cell || '').trim().toUpperCase()))) hotelRowIndex = i;
                        if (typeRowIndex === -1 && row.some(cell => EMPLOYMENT_TYPES.includes(String(cell || '').trim().toUpperCase()))) typeRowIndex = i;
                        
                        // Use a more robust check for the period row
                        let dateLikeCount = row.filter(cell => formatPeriod(cell, fileYear)).length;
                        if (periodRowIndex === -1 && dateLikeCount > 2) { // Require at least 3 date-like cells
                            periodRowIndex = i;
                        }
                    } catch (error) {
                        console.warn(`Error processing row ${i}:`, error);
                        continue;
                    }
                }

                if (hotelRowIndex === -1 || typeRowIndex === -1 || periodRowIndex === -1) {
                    throw new Error("HR Parser: Could not find required header rows (Hotel, Type, or Period).");
                }

                // --- Build a context map for each column ---
                const columnContextMap = new Map();
                const hotelRow = sheetData[hotelRowIndex];
                const typeRow = sheetData[typeRowIndex];
                const periodRow = sheetData[periodRowIndex];
                const maxCols = Math.max((hotelRow || []).length, (typeRow || []).length, (periodRow || []).length);

                // Helper to find the last valid value in a row, simulating merged cells
                const findLastValidValue = (row, colIndex, validSet) => {
                    try {
                        for (let k = colIndex; k >= 0; k--) {
                            const cellValue = String((row || [])[k] || '').trim().toUpperCase();
                            const foundValue = validSet.find(v => v.toUpperCase() === cellValue);
                            if (foundValue) return foundValue;
                        }
                        return null;
                    } catch (error) {
                        console.warn('Error in findLastValidValue:', error);
                        return null;
                    }
                };

                for (let j = 1; j < maxCols; j++) {
                    try {
                        const currentHotel = findLastValidValue(hotelRow, j, HOTEL_CODES);
                        const currentType = findLastValidValue(typeRow, j, EMPLOYMENT_TYPES);
                        const formattedPeriod = formatPeriod(periodRow[j], fileYear);

                        if (formattedPeriod && currentHotel && currentType) {
                            columnContextMap.set(j, { hotel: currentHotel, type: currentType, period: formattedPeriod });
                        }
                    } catch (error) {
                        console.warn(`Error processing column ${j}:`, error);
                        continue;
                    }
                }

                // --- Iterate through data rows and create flat records ---
                const dataStartIndex = periodRowIndex + 1;
                for (let i = dataStartIndex; i < sheetData.length; i++) {
                    try {
                        const row = sheetData[i] || [];
                        const rawDeptName = String(row[0] || '').trim();
                        
                        if (!rawDeptName || rawDeptName.toUpperCase().includes('TOTAL')) continue;
                        
                        if (STAFFING_DEPARTMENT_SET.has(rawDeptName.toUpperCase())) {
                            columnContextMap.forEach((context, colIndex) => {
                                try {
                                    const cellValue = row[colIndex];
                                    if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                                        const numericValue = parseFloat(String(cellValue).replace(/,/g, ''));
                                        if (!isNaN(numericValue) && isFinite(numericValue)) {
                                            structuredData.push({
                                                department: rawDeptName,
                                                hotel: context.hotel,
                                                type: context.type,
                                                period: context.period,
                                                value: numericValue
                                            });
                                        }
                                    }
                                } catch (error) {
                                    console.warn(`Error processing cell [${i}][${colIndex}]:`, error);
                                }
                            });
                        }
                    } catch (error) {
                        console.warn(`Error processing data row ${i}:`, error);
                        continue;
                    }
                }
                
                if (structuredData.length === 0) {
                    throw new Error("ไม่พบข้อมูลที่สามารถประมวลผลได้ในรูปแบบ HR Report");
                }
                
                return { data: structuredData, headers: finalHeaders };
            } catch (error) {
                console.error('Error in parseHrReportData:', error);
                throw error;
            }
        }
        
        /**
         * Parses a generic sheet by finding the most likely header row.
         * @param {Array<Array<any>>} dataAsArray - Raw data from the sheet.
         * @returns {{data: Array<Object>, headers: Array<string>}} - The parsed flat data and its headers.
         */
        function parseGenericData(dataAsArray) {
            const headerRowIndex = findGenericHeaderRow(dataAsArray);
            if (headerRowIndex === -1) {
                throw new Error("Generic Parser: Could not find a valid header row.");
            }

            const rawHeaders = dataAsArray[headerRowIndex].filter(h => h && String(h).trim());
            const dataRows = dataAsArray.slice(headerRowIndex + 1);

            const jsonData = dataRows.map(row => {
                const obj = {};
                rawHeaders.forEach(header => {
                    const originalIndex = dataAsArray[headerRowIndex].indexOf(header);
                    obj[header] = row[originalIndex];
                });
                return obj;
            });
            
            const sanitizedHeaders = rawHeaders.map(h => 
                String(h).trim()
                         .replace(/[.\s-()\[\]{}]/g, '_')
                         .replace(/_+/g, '_')
            );
            
            const sheetData = [];
            jsonData.forEach(row => {
                const newRow = {};
                rawHeaders.forEach((originalHeader, i) => {
                    const sanitizedHeader = sanitizedHeaders[i];
                    newRow[sanitizedHeader] = row[originalHeader];
                });
                sheetData.push(newRow);
            });

            return { data: sheetData, headers: sanitizedHeaders };
        }

        /**
         * Analyzes sheet rows to find the most likely header row for generic tables.
         * @param {Array<Array<string>>} dataAsArray - The sheet data as an array of arrays.
         * @returns {number} The index of the detected header row.
         */
        function findGenericHeaderRow(dataAsArray) {
            let bestGuess = { index: -1, score: -Infinity };
            const searchLimit = Math.min(dataAsArray.length - 1, 25); 

            const profileRow = (row) => {
                let stringCount = 0, numberCount = 0;
                const nonEmptyCells = [];
                if (!row) return { stringCount, numberCount, nonEmptyCells };
                row.forEach(cell => {
                    const value = cell === null || cell === undefined ? '' : String(cell).trim();
                    if (value !== '') {
                        nonEmptyCells.push(value);
                        const cleanVal = value.replace(/[,\s฿$€£¥]/g, '').replace(/^\((.+)\)$/, '-$1');
                        if (!isNaN(parseFloat(cleanVal)) && isFinite(cleanVal)) numberCount++;
                        else stringCount++;
                    }
                });
                return { stringCount, numberCount, nonEmptyCells };
            };

            for (let i = 0; i < searchLimit; i++) {
                const currentProfile = profileRow(dataAsArray[i]);
                const nextProfile = profileRow(dataAsArray[i + 1]);
                let score = 0;
                if (currentProfile.nonEmptyCells.length < 2 || nextProfile.nonEmptyCells.length === 0) continue;
                
                const stringRatio = currentProfile.stringCount / currentProfile.nonEmptyCells.length;
                score += stringRatio * 15;
                const numberRatio = currentProfile.numberCount / currentProfile.nonEmptyCells.length;
                score -= numberRatio * 10;
                score += currentProfile.nonEmptyCells.length * 1.5;
                const numberIncrease = nextProfile.numberCount - currentProfile.numberCount;
                if (numberIncrease > 0) score += numberIncrease * 8;
                const columnCountDifference = Math.abs(currentProfile.nonEmptyCells.length - nextProfile.nonEmptyCells.length);
                score -= columnCountDifference * 2;
                const uniqueness = new Set(currentProfile.nonEmptyCells).size / currentProfile.nonEmptyCells.length;
                score += uniqueness * 5;

                if (score > bestGuess.score) {
                    bestGuess.score = score;
                    bestGuess.index = i;
                }
            }
            return bestGuess.index === -1 ? 0 : bestGuess.index;
        }
        
        // --- NEW HELPER FUNCTION ---
        /**
         * Converts an Excel serial number to a JavaScript Date object.
         * @param {number} serial - The Excel serial number.
         * @returns {Date} The converted JavaScript Date object.
         */
        function excelSerialToDate(serial) {
            try {
                // Excel date system: January 1, 1900 is day 1 (serial = 1)
                // Excel incorrectly treats 1900 as a leap year, so we adjust for dates after Feb 28, 1900
                
                // For dates after Feb 28, 1900 (serial > 59), subtract 1 to correct Excel's leap year bug
                let daysSince1900 = serial > 59 ? serial - 1 : serial;
                
                // Excel epoch: January 1, 1900 00:00:00 local time
                const excelEpoch = new Date(1900, 0, 1);
                
                // Add the days (subtract 1 because Excel serial 1 = Jan 1, 1900, not Jan 2)
                const resultDate = new Date(excelEpoch.getTime() + (daysSince1900 - 1) * 86400000);
                
                // Validate the result
                if (isNaN(resultDate.getTime())) {
                    throw new Error(`Invalid date calculated from serial ${serial}`);
                }
                
                return resultDate;
            } catch (error) {
                console.error('Error converting Excel serial to date:', error);
                return new Date(); // Return current date as fallback
            }
        }

        /**
         * Parses a cell value into a "Mmm-YYYY" format. Returns null if invalid.
         * This version is stricter and handles numeric date serials manually.
         * @param {*} periodCell - The cell value to parse.
         * @param {string|null} defaultYear - The default year to use if not found in the cell.
         * @returns {string|null} The formatted period string or null.
         */
        function formatPeriod(periodCell, defaultYear = null) {
            try {
                if (periodCell === null || periodCell === undefined || String(periodCell).trim() === '') {
                    return null;
                }

                const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                // 1. Handle if the cell is a number (likely an Excel date serial)
                if (typeof periodCell === 'number') {
                    // Add a sanity check to avoid converting regular numbers like "2025".
                    // Excel serial numbers for dates around this era are > 40000.
                    if (periodCell > 40000 && periodCell < 60000) { // Dates from ~2010 to ~2065
                        const date = excelSerialToDate(periodCell);
                        if (date && !isNaN(date.getTime())) {
                             const month = monthNames[date.getMonth()];
                             let year = date.getFullYear();
                             
                             // Override year if defaultYear is provided (from filename)
                             if (defaultYear) {
                                 year = parseInt(defaultYear) || year;
                             }
                             
                             return `${month}-${year}`;
                        }
                    }
                    return null;
                }

                // 2. Handle if it's already a JavaScript Date object
                if (periodCell instanceof Date) {
                    if (isNaN(periodCell.getTime())) {
                        return null;
                    }
                    const month = monthNames[periodCell.getMonth()];
                    const year = periodCell.getFullYear();
                    return `${month}-${year}`;
                }
                
                // 3. Handle if it's a string
                const periodRaw = String(periodCell).trim();

                // Handle DD/MM/YYYY format (Thai/European style - like 01/05/2025 = 1 May 2025)
                const dateMatch = periodRaw.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
                if (dateMatch) {
                    const day = parseInt(dateMatch[1], 10);
                    const month = parseInt(dateMatch[2], 10);    // Second number is month
                    const year = parseInt(dateMatch[3], 10);
                    
                    // Validate the date components
                    if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year > 1900 && year < 2100) {
                        const monthIndex = month - 1; // Convert to 0-based index
                        const monthName = monthNames[monthIndex];
                        return `${monthName}-${year}`;
                    }
                }

                // Handle month name patterns
                const monthPattern = `^(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)$`;
                const mainRegex = new RegExp(monthPattern, 'i');
                const match = periodRaw.match(mainRegex);

                if (match) {
                    const monthStr = match[1];
                    const month = monthStr.charAt(0).toUpperCase() + monthStr.slice(1, 3).toLowerCase();
                    // Use defaultYear from filename if available, otherwise current year
                    const year = defaultYear || new Date().getFullYear();
                    return `${month}-${year}`;
                }

                return null;
            } catch (error) {
                console.error('Error in formatPeriod:', error);
                return null;
            }
        }

        function processAndStoreSheets(sheetNames) {
            try {
                if (!sheetNames || !Array.isArray(sheetNames) || sheetNames.length === 0) {
                    throw new Error("ไม่ได้ระบุ sheets ที่จะประมวลผล");
                }

                if (sheetSelectModal) sheetSelectModal.hide();
                loadingSpinner.style.display = 'block';
                uploadErrorEl.textContent = '';
                
                workbookDataStore = {};
                let processedSheetCount = 0;
                const yearMatch = currentFileName.match(/\b(20\d{2})\b/);
                const fileYear = yearMatch ? yearMatch[1] : null;
                const processingErrors = [];

                sheetNames.forEach(sheetName => {
                    try {
                        if (!sheetName || typeof sheetName !== 'string') {
                            throw new Error(`ชื่อ sheet ไม่ถูกต้อง: ${sheetName}`);
                        }

                        loadingStatusEl.textContent = `กำลังอ่านชีต: ${sheetName}...`;
                        const ws = workbook.Sheets[sheetName];
                        if (!ws) {
                            throw new Error(`ไม่พบ worksheet: ${sheetName}`);
                        }

                        const dataAsArray = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });
                        if (!Array.isArray(dataAsArray)) {
                            throw new Error(`ข้อมูลจาก sheet "${sheetName}" ไม่ใช่ array`);
                        }
                        
                        if (dataAsArray.length < 5) {
                            console.warn(`Sheet "${sheetName}" มีข้อมูลน้อยเกินไป (${dataAsArray.length} rows) - ข้าม`);
                            return;
                        }

                        let parsedResult = null;
                        try {
                            const hrResult = parseHrReportData(dataAsArray, fileYear);
                            if (hrResult && hrResult.data && hrResult.data.length > 0) {
                                parsedResult = hrResult;
                            } else {
                                throw new Error("HR Parser found no data.");
                            }
                        } catch (hrError) {
                            console.warn(`HR Parser failed for sheet "${sheetName}", falling back to generic parser. Reason: ${hrError.message}`);
                            try {
                                const genericResult = parseGenericData(dataAsArray);
                                if (genericResult && genericResult.data && genericResult.data.length > 0) {
                                    parsedResult = genericResult;
                                }
                            } catch (genericError) {
                                console.error(`Generic parser also failed for sheet "${sheetName}":`, genericError);
                                throw new Error(`ไม่สามารถประมวลผลข้อมูลจาก sheet "${sheetName}" ได้ด้วยทั้ง HR และ Generic parser`);
                            }
                        }
                        
                        if (parsedResult) {
                            workbookDataStore[sheetName] = parsedResult;
                            processedSheetCount++;
                        }

                    } catch (error) {
                        const errorMsg = `Error processing sheet "${sheetName}": ${error.message}`;
                        console.error(errorMsg);
                        processingErrors.push(errorMsg);
                    }
                });

                if (processedSheetCount === 0) {
                    const errorDetail = processingErrors.length > 0 ? `\nรายละเอียด: ${processingErrors.join('; ')}` : '';
                    throw new Error(`ไม่สามารถหาข้อมูลที่สามารถวิเคราะห์ได้ในชีตที่เลือก${errorDetail}`);
                }
                
                if (processingErrors.length > 0) {
                    console.warn(`ประมวลผลได้ ${processedSheetCount}/${sheetNames.length} sheets. Errors:`, processingErrors);
                }
                
                generateAndShowTemplates();

            } catch (error) {
                console.error('Error in processAndStoreSheets:', error);
                uploadErrorEl.textContent = "เกิดข้อผิดพลาดในการประมวลผล: " + error.message;
                loadingSpinner.style.display = 'none';
                throw error;
            }
        }

        function startHeaderConfigurationFlow(sheetNames) {
            sheetsToConfigure = sheetNames;
            currentConfigSheetIndex = 0;
            displaySheetForConfiguration();
            headerConfigModal.show();
        }

        function displaySheetForConfiguration() {
            const sheetName = sheetsToConfigure[currentConfigSheetIndex];
            getEl('header-config-modal-title').textContent = `ตั้งค่าคอลัมน์สำหรับ: ${sheetName}`;
            
            const listContainer = getEl('header-config-list');
            listContainer.innerHTML = '';
            const allPossibleHeaders = workbookDataStore[sheetName].headers;

            allPossibleHeaders.forEach(header => {
                const item = document.createElement('label');
                item.className = 'list-group-item';
                item.innerHTML = `<input class="form-check-input me-2" type="checkbox" value="${header}" checked> ${header}`;
                listContainer.appendChild(item);
            });

            const nextButton = getEl('next-header-config-btn');
            if (currentConfigSheetIndex >= sheetsToConfigure.length - 1) {
                nextButton.textContent = 'เสร็จสิ้น';
            } else {
                nextButton.textContent = 'ชีตถัดไป';
            }
        }

        function processCurrentSheetConfiguration() {
            const sheetName = sheetsToConfigure[currentConfigSheetIndex];
            const selectedCheckboxes = getEl('header-config-list').querySelectorAll('input:checked');
            const selectedHeaders = Array.from(selectedCheckboxes).map(cb => cb.value);

            if (selectedHeaders.length === 0) {
                alert(`กรุณาเลือกอย่างน้อย 1 คอลัมน์สำหรับชีต ${sheetName}`);
                return;
            }
            
            workbookDataStore[sheetName].selectedHeaders = selectedHeaders;
            
            currentConfigSheetIndex++;

            if (currentConfigSheetIndex < sheetsToConfigure.length) {
                displaySheetForConfiguration();
            } else {
                finishHeaderConfiguration();
            }
        }

        function finishHeaderConfiguration() {
            headerConfigModal.hide();
            loadingSpinner.style.display = 'block';
            loadingStatusEl.textContent = 'กำลังตั้งค่า Dashboard...';

            Object.keys(workbookDataStore).forEach(sheetName => {
                const sheetInfo = workbookDataStore[sheetName];
                if (sheetInfo.selectedHeaders) {
                    const selected = sheetInfo.selectedHeaders;
                    
                    sheetInfo.data = sheetInfo.data.map(fullRow => {
                        const newRow = {};
                        selected.forEach(h => {
                            newRow[h] = fullRow[h];
                        });
                        return newRow;
                    });
                    
                    sheetInfo.headers = selected;
                }
            });

            setActiveSheet(Object.keys(workbookDataStore)[0]);
            loadingSpinner.style.display = 'none';
        }


        function setActiveSheet(sheetName) {
            if (!workbookDataStore[sheetName]) return;

            Object.values(chartInstances).forEach(chart => chart.destroy());
            chartInstances = {};
            activeFilters = [];
            userKPIs = [];
            userCharts = [];
            if (filterBuilderContainer) filterBuilderContainer.innerHTML = '';
            if (kpisContainer) kpisContainer.innerHTML = '';
            if (chartsContainer) chartsContainer.innerHTML = '';

            currentSheetName = sheetName;
            const sheetInfo = workbookDataStore[sheetName];
            
            fullOriginalData = sheetInfo.data;
            allHeaders = sheetInfo.headers; 
            
            headers = [...allHeaders];
            originalData = [...fullOriginalData];

            initializeDashboard();
        }
        
        function convertNumericColumns() {
            if (!numericHeaders || numericHeaders.length === 0) return;
            fullOriginalData.forEach(row => {
                numericHeaders.forEach(h => {
                    const val = row[h];
                    if (val !== null && val !== undefined && val !== '') {
                        const strVal = String(val).trim();
                        let cleanVal = strVal.replace(/[,\s฿$€£¥"']/g, '').replace(/^\((.+)\)$/, '-$1').replace(/[^\d.-]/g, '');
                        let numVal = parseFloat(cleanVal);
                        
                        if (!isNaN(numVal) && isFinite(numVal)) {
                            row[h] = numVal;
                        } else {
                            row[h] = 0;
                        }
                    } else {
                        row[h] = 0;
                    }
                });
            });
            originalData = [...fullOriginalData];
        }

        /**
         * ลบแถวที่มีค่า null หรือ empty ทั้งแถว
         */
        function removeEmptyRows() {
            try {
                const initialCount = fullOriginalData.length;
                
                fullOriginalData = fullOriginalData.filter(row => {
                    // ตรวจสอบว่าทุกคอลัมน์ในแถวนี้เป็น null, undefined, หรือ empty string หรือไม่
                    const hasAnyValue = headers.some(header => {
                        const value = row[header];
                        return value !== null && 
                               value !== undefined && 
                               String(value).trim() !== '' &&
                               String(value).trim() !== 'null' &&
                               String(value).trim() !== 'NULL';
                    });
                    
                    return hasAnyValue; // เก็บแถวที่มีค่าอย่างน้อย 1 คอลัมน์
                });
                
                const removedCount = initialCount - fullOriginalData.length;
                if (removedCount > 0) {
                    console.log(`ลบแถวว่างออกไปแล้ว ${removedCount} แถว จาก ${initialCount} แถว`);
                }
                
                originalData = [...fullOriginalData];
                
            } catch (error) {
                console.error('Error in removeEmptyRows:', error);
            }
        }

        function detectNumericHeaders() {
            numericHeaders = allHeaders.filter(h => {
                const nonEmptyValues = fullOriginalData.map(row => row[h]).filter(val => val !== null && val !== undefined && String(val).trim() !== '');
                if (nonEmptyValues.length < 5) return false;
                
                const numericCount = nonEmptyValues.filter(val => {
                    const strVal = String(val).trim();
                    const cleanVal = strVal.replace(/[,\s฿$€£¥]/g, '').replace(/^\((.+)\)$/, '-$1');
                    return !isNaN(parseFloat(cleanVal)) && isFinite(cleanVal);
                }).length;
                
                return (numericCount / nonEmptyValues.length) >= 0.7;
            });
        }
        
        function generateDashboardTemplates(sheetName) {
            const sheetInfo = workbookDataStore[sheetName];
            const currentAllHeaders = sheetInfo.headers;
            const currentNumericHeaders = currentAllHeaders.filter(h => {
                 const nonEmptyValues = sheetInfo.data.map(row => row[h]).filter(val => val !== null && val !== undefined && String(val).trim() !== '');
                if (nonEmptyValues.length < 5) return false;
                const numericCount = nonEmptyValues.filter(val => {
                    const strVal = String(val).trim();
                    const cleanVal = strVal.replace(/[,\s฿$€£¥]/g, '').replace(/^\((.+)\)$/, '-$1');
                    return !isNaN(parseFloat(cleanVal)) && isFinite(cleanVal);
                }).length;
                return (numericCount / nonEmptyValues.length) >= 0.7;
            });

            const templates = [];
            
            if (currentAllHeaders.includes('department') && currentAllHeaders.includes('hotel') && currentAllHeaders.includes('value')) {
                 const config = {
                    headers: ['department', 'hotel', 'type', 'period', 'value'],
                    userKPIs: [
                        { id: `kpi-hr-1`, title: `พนักงานทั้งหมด`, calculation: 'sum', column: 'value' },
                        { id: `kpi-hr-2`, title: `จำนวนแผนก`, calculation: 'uniqueCount', column: 'department' },
                        { id: `kpi-hr-3`, title: `จำนวนโรงแรม`, calculation: 'uniqueCount', column: 'hotel' }
                    ],
                    userCharts: [
                        { id: 'chart-hr-1', title: 'จำนวนพนักงานตามแผนก', type: 'bar', groupBy: 'department', metric: 'value', aggregation: 'sum' },
                        { id: 'chart-hr-2', title: 'จำนวนพนักงานตามโรงแรม', type: 'pie', groupBy: 'hotel', metric: 'value', aggregation: 'sum' }
                    ]
                };
                templates.push({ name: "วิเคราะห์ข้อมูลพนักงาน (HR Staffing)", description: "ภาพรวมจำนวนพนักงาน แยกตามแผนกและโรงแรม", config });
            }

            if (currentNumericHeaders.length > 0 && currentAllHeaders.length > currentNumericHeaders.length) {
                const firstCategoryCol = currentAllHeaders.find(h => !currentNumericHeaders.includes(h));
                const firstNumericCol = currentNumericHeaders[0];
                if (firstCategoryCol && firstNumericCol) {
                    const config = {
                         headers: currentAllHeaders,
                         userKPIs: [
                            { id: 'kpi-gen-1', title: 'จำนวนรายการทั้งหมด', calculation: 'count', column: null },
                            { id: 'kpi-gen-2', title: `ผลรวม ${firstNumericCol}`, calculation: 'sum', column: firstNumericCol },
                         ],
                         userCharts: [{ id: 'chart-gen-1', title: `ผลรวม ${firstNumericCol} ตาม ${firstCategoryCol}`, type: 'bar', groupBy: firstCategoryCol, metric: firstNumericCol, aggregation: 'sum' }]
                    };
                    templates.push({ name: "สำรวจข้อมูลเบื้องต้น (General Exploration)", description: `นับจำนวนรายการและดูผลรวมของ ${firstNumericCol} ตาม ${firstCategoryCol}`, config });
                }
            }

            return templates;
        }

        function generateAndShowTemplates() {
            try {
                if (!workbookDataStore || typeof workbookDataStore !== 'object' || Object.keys(workbookDataStore).length === 0) {
                    throw new Error("ไม่มีข้อมูล workbook ที่จะสร้าง template");
                }

                const firstSheetName = Object.keys(workbookDataStore)[0];
                if (!firstSheetName) {
                    throw new Error("ไม่พบ sheet name ใน workbook data");
                }

                const templates = generateDashboardTemplates(firstSheetName);
                const container = getEl('template-card-container');
                
                if (!container) {
                    throw new Error("ไม่พบ template container element");
                }
                
                container.innerHTML = '';

                if (!templates || !Array.isArray(templates) || templates.length === 0) {
                    console.warn("ไม่พบ templates ที่เหมาะสม - เริ่มกระบวนการ header configuration");
                    startHeaderConfigurationFlow(Object.keys(workbookDataStore));
                    return;
                }

                // สร้าง template cards
                templates.forEach((template, index) => {
                    try {
                        if (!template || typeof template !== 'object') {
                            console.warn(`Template at index ${index} is invalid:`, template);
                            return;
                        }

                        const cardWrapper = document.createElement('div');
                        cardWrapper.className = 'col-md-6';
                        
                        const card = document.createElement('div');
                        card.className = 'card h-100 template-card border';
                        card.onclick = () => applyTemplateAndInitialize(template.config, firstSheetName);
                        
                        const firstChartConfig = template.config?.userCharts?.[0];
                        const previewCanvasId = firstChartConfig ? `preview-${firstChartConfig.id}` : `preview-empty-${index}`;

                        card.innerHTML = `
                            <div class="chart-preview-container bg-light p-2 rounded-top">
                                <canvas id="${previewCanvasId}"></canvas>
                            </div>
                            <div class="card-body">
                                <h5 class="card-title text-primary">${template.name || 'Unnamed Template'}</h5>
                                <p class="card-text text-muted small">${template.description || 'No description available'}</p>
                            </div>
                        `;
                        cardWrapper.appendChild(card);
                        container.appendChild(cardWrapper);
                    } catch (error) {
                        console.error(`Error creating template card ${index}:`, error);
                    }
                });
                
                // สร้าง preview charts
                templates.forEach((template, index) => {
                    try {
                        const firstChartConfig = template.config?.userCharts?.[0];
                        if (firstChartConfig) {
                            const previewCanvasId = `preview-${firstChartConfig.id}`;
                            renderPreviewChart(firstChartConfig, previewCanvasId, firstSheetName);
                        }
                    } catch (error) {
                        console.error(`Error rendering preview chart for template ${index}:`, error);
                    }
                });

                loadingSpinner.style.display = 'none';
                
                if (!templateSelectModal) {
                    throw new Error("templateSelectModal ไม่ได้ถูก initialized");
                }
                
                templateSelectModal.show();
                
            } catch (error) {
                console.error('Error in generateAndShowTemplates:', error);
                loadingSpinner.style.display = 'none';
                uploadErrorEl.textContent = `เกิดข้อผิดพลาดในการสร้าง template: ${error.message}`;
                throw error;
            }
        }

        function renderPreviewChart(config, canvasId, sheetName) {
            try {
                if (!config || typeof config !== 'object') {
                    throw new Error("Chart config ไม่ถูกต้อง");
                }

                if (!canvasId || typeof canvasId !== 'string') {
                    throw new Error("Canvas ID ไม่ถูกต้อง");
                }

                if (!sheetName || !workbookDataStore[sheetName]) {
                    throw new Error(`ไม่พบข้อมูลสำหรับ sheet: ${sheetName}`);
                }

                const data = workbookDataStore[sheetName].data;
                if (!data || !Array.isArray(data) || data.length === 0) {
                    console.warn(`ไม่มีข้อมูลสำหรับ preview chart ใน sheet: ${sheetName}`);
                    return;
                }

                if (!config.groupBy) {
                    console.warn("ไม่ได้ระบุ groupBy สำหรับ chart");
                    return;
                }

                let chartData;
                const aggregation = config.aggregation || 'sum';
                const metric = config.metric;

                try {
                    if (aggregation === 'count' || aggregation === 'uniqueCount') {
                        const counts = data.reduce((acc, row) => {
                            try {
                                const key = row[config.groupBy] || 'N/A';
                                if (!acc[key]) acc[key] = new Set();
                                if (aggregation === 'uniqueCount') acc[key].add(row[metric]);
                                else acc[key].add(row[config.groupBy]);
                                return acc;
                            } catch (error) {
                                console.warn('Error processing row for count aggregation:', error);
                                return acc;
                            }
                        }, {});
                        chartData = { 
                            labels: Object.keys(counts), 
                            values: Object.values(counts).map(s => s.size) 
                        };
                    } else { 
                        const metrics = data.reduce((acc, row) => {
                            try {
                                const key = row[config.groupBy] || 'N/A';
                                if (!acc[key]) acc[key] = { sum: 0, count: 0 };
                                const value = parseFloat(row[metric] || 0);
                                if (!isNaN(value) && isFinite(value)) {
                                    acc[key].sum += value;
                                    acc[key].count += 1;
                                }
                                return acc;
                            } catch (error) {
                                console.warn('Error processing row for numeric aggregation:', error);
                                return acc;
                            }
                        }, {});
                        
                        chartData = {
                            labels: Object.keys(metrics),
                            values: Object.values(metrics).map(m => {
                                if (m.count === 0) return 0;
                                return aggregation === 'sum' ? m.sum : (m.sum / m.count);
                            })
                        };
                    }
                } catch (error) {
                    throw new Error(`Error aggregating data: ${error.message}`);
                }

                if (!chartData.labels || chartData.labels.length === 0) {
                    console.warn("ไม่มีข้อมูลสำหรับ chart หลังจาก aggregation");
                    return;
                }

                // จำกัดจำนวนจุดข้อมูลสำหรับ preview
                const maxPreviewPoints = 10;
                if (chartData.labels.length > maxPreviewPoints) {
                    try {
                        const combined = chartData.labels.map((label, i) => ({ 
                            label, 
                            value: chartData.values[i] || 0 
                        }));
                        combined.sort((a, b) => b.value - a.value);
                        chartData.labels = combined.slice(0, maxPreviewPoints).map(d => d.label);
                        chartData.values = combined.slice(0, maxPreviewPoints).map(d => d.value);
                    } catch (error) {
                        console.warn('Error limiting preview data points:', error);
                    }
                }

                const canvas = getEl(canvasId);
                if (!canvas) {
                    console.warn(`ไม่พบ canvas element: ${canvasId}`);
                    return;
                }

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.warn(`ไม่สามารถสร้าง 2d context สำหรับ canvas: ${canvasId}`);
                    return;
                }

                // ทำลาย chart instance เก่าถ้ามี
                if (chartInstances[canvasId]) {
                    try {
                        chartInstances[canvasId].destroy();
                    } catch (error) {
                        console.warn('Error destroying existing chart:', error);
                    }
                }

                chartInstances[canvasId] = new Chart(ctx, {
                    type: config.type || 'bar',
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            data: chartData.values,
                            backgroundColor: config.type === 'line' ? 'rgba(0, 123, 255, 0.1)' : ['#0d6efd', '#6c757d', '#198754', '#ffc107', '#dc3545', '#0dcaf0', '#fd7e14'],
                            borderColor: '#0d6efd',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: config.type === 'line'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false }, 
                            tooltip: { enabled: false }, 
                            datalabels: { display: false } 
                        },
                        scales: { 
                            x: { display: false }, 
                            y: { display: false } 
                        }
                    }
                });

            } catch (error) {
                console.error(`Error in renderPreviewChart for canvas ${canvasId}:`, error);
            }
        }

        function applyTemplateAndInitialize(config, sheetName) {
            templateSelectModal.hide();
            loadingSpinner.style.display = 'block';

            const firstSheetInfo = workbookDataStore[sheetName];
            firstSheetInfo.selectedHeaders = [...new Set(config.headers)];
            firstSheetInfo.data = firstSheetInfo.data.map(fullRow => {
                const newRow = {};
                firstSheetInfo.selectedHeaders.forEach(h => { newRow[h] = fullRow[h]; });
                return newRow;
            });
            firstSheetInfo.headers = firstSheetInfo.selectedHeaders;

            Object.keys(workbookDataStore).forEach(sName => {
                if (sName !== sheetName) {
                    const otherSheetInfo = workbookDataStore[sName];
                    otherSheetInfo.selectedHeaders = otherSheetInfo.headers;
                }
            });

            setActiveSheet(sheetName);
            
            userKPIs = config.userKPIs || [];
            userCharts = config.userCharts || [];
            activeFilters = config.activeFilters || [];
            
            applyFiltersAndRender();
            
            loadingSpinner.style.display = 'none';
        }

        function renderSheetSwitcher() {
            const container = getEl('sheet-switcher-container');
            container.innerHTML = '';
            const sheetNames = Object.keys(workbookDataStore);

            if (sheetNames.length > 1) {
                const switcherGroup = document.createElement('div');
                switcherGroup.className = 'btn-group btn-group-sm mt-2';
                switcherGroup.setAttribute('role', 'group');
                
                sheetNames.forEach(name => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = `btn ${name === currentSheetName ? 'btn-primary' : 'btn-outline-primary'}`;
                    button.textContent = name;
                    button.onclick = () => {
                        if (name !== currentSheetName) {
                            setActiveSheet(name);
                        }
                    };
                    switcherGroup.appendChild(button);
                });
                container.appendChild(switcherGroup);
            }
        }

        function initializeDashboard() {
            fileInfoEl.textContent = `ไฟล์: ${currentFileName}`;
            uploadView.classList.add('d-none');
            dashboardView.classList.remove('d-none');
            
            renderSheetSwitcher();
            
            detectNumericHeaders();
            removeEmptyRows(); // ลบแถวว่างก่อนประมวลผลข้อมูล
            convertNumericColumns();

            sortKey = headers.length > 0 ? headers[0] : '';
            renderTableHeader();

            const savedConfig = loadStateFromLocalStorage();
            
            const headersMatch = savedConfig && savedConfig.headers && savedConfig.headers.every(h => headers.includes(h)) && savedConfig.headers.length === headers.length;

            if (headersMatch) {
                applyConfiguration(savedConfig);
            } else {
                applyFiltersAndRender();
            }
        }

        function renderTableHeader() {
            tableHeaderEl.innerHTML = '';
            const tr = document.createElement('tr');
            tr.className = 'main-header-row';
            
            headers.forEach((header, colIndex) => {
                const th = document.createElement('th');
                th.className = 'p-1 sortable-header';
                th.dataset.sortKey = header;
                th.textContent = header;
                
                // ใช้ styling แบบ Excel เสมอ
                th.style.cssText = `
                    cursor: pointer; 
                    position: relative; 
                    background-color: #f6f8fa; 
                    font-weight: 600; 
                    border: 1px solid #d0d7de;
                    text-align: center;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    font-size: 13px;
                `;
                
                // เพิ่ม hover effect
                th.addEventListener('mouseenter', () => {
                    th.style.backgroundColor = '#e9ecef';
                });
                th.addEventListener('mouseleave', () => {
                    th.style.backgroundColor = '#f6f8fa';
                });
                
                tr.appendChild(th);
            });
            
            tableHeaderEl.appendChild(tr);
            updateSortIndicators();
        }
        
        function renderTableTotalRow() {
            const existingTotalRow = tableHeaderEl.querySelector('.total-row');
            if (existingTotalRow) existingTotalRow.remove();
            if (filteredData.length === 0) return;

            const totalRow = document.createElement('tr');
            totalRow.className = 'table-light total-row fw-bold';

            let hasPlacedTotalLabel = false;
            headers.forEach(header => {
                const th = document.createElement('th');
                th.className = 'p-3';
                if (numericHeaders.includes(header)) {
                    const total = filteredData.reduce((sum, row) => sum + (row[header] || 0), 0);
                    th.textContent = total.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                    th.classList.add('text-end');
                } else {
                    if (!hasPlacedTotalLabel) {
                        th.textContent = 'Total';
                        hasPlacedTotalLabel = true;
                    } else {
                        th.textContent = '';
                    }
                }
                totalRow.appendChild(th);
            });
            tableHeaderEl.prepend(totalRow);
        }


        function renderTableBody() {
            tableBodyEl.innerHTML = '';
            noResultsEl.classList.toggle('d-none', filteredData.length > 0);
            if (filteredData.length === 0) return;

            const totalPages = Math.ceil(filteredData.length / rowsPerPage);
            currentPage = Math.min(currentPage, totalPages) || 1;
            const start = (currentPage - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            const paginatedItems = filteredData.slice(start, end);

            // ใช้รูปแบบ Excel เสมอ (ไม่ต้องอิงจาก Excel data จริง)
            paginatedItems.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                
                headers.forEach((header, colIndex) => {
                    const td = document.createElement('td');
                    td.className = 'p-1';
                    const value = row[header];
                    
                    // จัดรูปแบบตามประเภทข้อมูล
                    if (typeof value === 'number' && numericHeaders.includes(header)) {
                        td.textContent = value.toLocaleString('th-TH');
                        td.classList.add('text-end', 'excel-number');
                        td.style.fontFamily = 'Consolas, Monaco, "Lucida Console", monospace';
                    } else if (value instanceof Date) {
                        td.textContent = value.toLocaleDateString('th-TH');
                        td.classList.add('text-center', 'excel-date');
                    } else {
                        td.textContent = String(value === undefined || value === null ? '' : value);
                        td.classList.add('excel-text');
                    }
                    
                    // เพิ่ม hover effect
                    td.addEventListener('mouseenter', () => {
                        td.style.backgroundColor = '#f1f8ff';
                    });
                    td.addEventListener('mouseleave', () => {
                        td.style.backgroundColor = '';
                    });
                    
                    tr.appendChild(td);
                });
                tableBodyEl.appendChild(tr);
            });
            
            renderPaginationControls(filteredData.length, totalPages);
        }

        function renderPaginationControls(totalItems, totalPages) {
            paginationControls.innerHTML = '';
            if (totalItems === 0) return;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'd-flex align-items-center gap-3';
            const startItem = (currentPage - 1) * rowsPerPage + 1;
            const endItem = Math.min(startItem + rowsPerPage - 1, totalItems);
            
            const pageInfo = document.createElement('span');
            pageInfo.className = 'text-muted text-nowrap';
            pageInfo.textContent = `แสดง ${startItem} - ${endItem} จาก ${totalItems}`;

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'btn-group';
            const prevButton = document.createElement('button');
            prevButton.innerHTML = '&laquo;';
            prevButton.className = 'btn btn-outline-secondary btn-sm';
            prevButton.disabled = currentPage === 1;
            prevButton.onclick = () => { if (currentPage > 1) { currentPage--; renderTableBody(); } };
            const nextButton = document.createElement('button');
            nextButton.innerHTML = '&raquo;';
            nextButton.className = 'btn btn-outline-secondary btn-sm';
            nextButton.disabled = currentPage === totalPages;
            nextButton.onclick = () => { if (currentPage < totalPages) { currentPage++; renderTableBody(); } };

            buttonsContainer.append(prevButton, nextButton);
            wrapper.append(pageInfo, buttonsContainer);
            paginationControls.append(wrapper);
        }

        function applyFiltersAndRender() {
            let data = [...originalData];
            activeFilters.forEach(filter => {
                if (filter.column && filter.value) {
                    const filterValue = String(filter.value).toLowerCase();
                    data = data.filter(row => String(row[filter.column] || '').toLowerCase().includes(filterValue));
                }
            });

            filteredData = data;
            currentPage = 1;
            sortData();
            renderTableBody();
            renderTableTotalRow();
            renderAllKpis();
            renderAllCharts();
        }

        function addFilterRow(filterConfig = null) {
            const filterId = filterConfig ? filterConfig.id : `filter-${Date.now()}`;
            const filterRow = document.createElement('div');
            filterRow.id = filterId;
            filterRow.className = 'row g-2 align-items-center mb-2 p-2 filter-row';
            const headerOptions = headers.map(h => `<option value="${h}" ${filterConfig && filterConfig.column === h ? 'selected' : ''}>${h}</option>`).join('');
            filterRow.innerHTML = `
                <div class="col-md-5"><select class="form-select form-select-sm" data-role="column"><option value="">-- เลือกคอลัมน์ --</option>${headerOptions}</select></div>
                <div class="col-md-6"><input type="text" class="form-control form-control-sm" placeholder="ค่าที่ต้องการค้นหา..." data-role="value" value="${filterConfig ? (filterConfig.value || '') : ''}"></div>
                <div class="col-md-1"><button class="btn btn-sm btn-outline-danger" data-role="remove"><i class="bi bi-trash"></i></button></div>`;
            filterBuilderContainer.appendChild(filterRow);
            
            const currentFilter = activeFilters.find(f => f.id === filterId);
            const newFilter = currentFilter || { id: filterId, column: filterConfig?.column || '', value: filterConfig?.value || '' };
            if (!currentFilter) activeFilters.push(newFilter);

            filterRow.querySelector('[data-role="column"]').addEventListener('change', (e) => { newFilter.column = e.target.value; saveStateToLocalStorage(); applyFiltersAndRender(); });
            filterRow.querySelector('[data-role="value"]').addEventListener('input', (e) => { newFilter.value = e.target.value; saveStateToLocalStorage(); applyFiltersAndRender(); });
            filterRow.querySelector('[data-role="remove"]').addEventListener('click', () => { activeFilters = activeFilters.filter(f => f.id !== filterId); filterRow.remove(); saveStateToLocalStorage(); applyFiltersAndRender(); });
        }

        function sortData() {
            if (!sortKey) return;
            const isNumeric = numericHeaders.includes(sortKey);
            
            filteredData.sort((a, b) => {
                let valA = a[sortKey];
                let valB = b[sortKey];
                if (isNumeric) { valA = valA || 0; valB = valB || 0; } 
                else { valA = String(valA || '').toLowerCase(); valB = String(valB || '').toLowerCase(); }
                if (valA < valB) return sortDir === 'asc' ? -1 : 1;
                if (valA > valB) return sortDir === 'asc' ? 1 : -1;
                return 0;
            });
            updateSortIndicators();
        }

        function updateSortIndicators() {
            tableHeaderEl.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sortKey === sortKey) th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
            });
        }

        function openCreateKpiModal() {
            getEl('create-kpi-form').reset();
            const calcSelect = getEl('kpi-calculation');
            const colSelect = getEl('kpi-column');
            const colContainer = getEl('kpi-column-container');
            
            calcSelect.innerHTML = `<option value="">-- เลือก --</option><option value="sum">ผลรวม (Sum)</option><option value="average">ค่าเฉลี่ย (Average)</option><option value="uniqueCount">จำนวนนับ (ไม่ซ้ำ)</option><option value="count">จำนวนนับ (ทั้งหมด)</option>`;
            
            calcSelect.onchange = () => {
                const selection = calcSelect.value;
                let colOptions = '';
                if (selection === 'sum' || selection === 'average') { colOptions = numericHeaders.map(h => `<option value="${h}">${h}</option>`).join(''); colContainer.style.display = 'block'; } 
                else if (selection === 'uniqueCount') { colOptions = headers.map(h => `<option value="${h}">${h}</option>`).join(''); colContainer.style.display = 'block'; } 
                else { colContainer.style.display = 'none'; }
                colSelect.innerHTML = colOptions;
            };
            calcSelect.onchange();
            kpiModal.show();
        }

        function saveKpi() {
            const form = getEl('create-kpi-form');
            if (!form.checkValidity()) { form.classList.add('was-validated'); return; }
            const calculation = getEl('kpi-calculation').value;
            userKPIs.push({
                id: `kpi-${Date.now()}`,
                title: getEl('kpi-title').value,
                calculation: calculation,
                column: calculation !== 'count' ? getEl('kpi-column').value : null
            });
            kpiModal.hide();
            saveStateToLocalStorage();
            renderAllKpis();
        }

        function renderAllKpis() {
            kpisContainer.innerHTML = '';
            if (userKPIs.length === 0) { kpisContainer.appendChild(noKpisPlaceholder); noKpisPlaceholder.style.display = 'block'; return; }
            noKpisPlaceholder.style.display = 'none';

            userKPIs.forEach(config => {
                let value = 0;
                const data = filteredData;
                switch(config.calculation) {
                    case 'sum': value = data.reduce((sum, row) => sum + (row[config.column] || 0), 0); break;
                    case 'average': const sum = data.reduce((s, row) => s + (row[config.column] || 0), 0); value = data.length > 0 ? sum / data.length : 0; break;
                    case 'uniqueCount': value = new Set(data.map(row => row[config.column])).size; break;
                    case 'count': value = data.length; break;
                }
                const kpiWrapper = document.createElement('div');
                kpiWrapper.className = 'col-md-4 col-sm-6 mb-4 kpi-card';
                let formattedValue = (config.calculation === 'sum' || config.calculation === 'average') ? value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : value.toLocaleString();
                kpiWrapper.innerHTML = `<div class="card position-relative"><div class="card-body text-center p-4"><h2 class="text-muted fs-6 mb-2">${config.title}</h2><p class="h2 fw-bold text-primary mb-0">${formattedValue}</p></div><button class="btn btn-sm btn-danger position-absolute top-0 end-0 m-2" style="line-height:1" data-kpi-id="${config.id}" title="ลบ KPI">&times;</button></div>`;
                kpisContainer.appendChild(kpiWrapper);
            });
            kpisContainer.querySelectorAll('[data-kpi-id]').forEach(btn => btn.addEventListener('click', (e) => { userKPIs = userKPIs.filter(k => k.id !== e.currentTarget.dataset.kpiId); saveStateToLocalStorage(); renderAllKpis(); }));
        }

        function openCreateChartModal() {
            getEl('create-chart-form').reset();
            const groupBySelect = getEl('chart-group-by');
            const metricSelect = getEl('chart-metric');
            const aggregationContainer = getEl('metric-aggregation-container');
            const allHeaderOptions = headers.map(h => `<option value="${h}">${h}</option>`).join('');
            const numericHeaderOptions = numericHeaders.map(h => `<option value="${h}">${h}</option>`).join('');
            groupBySelect.innerHTML = `<option value="">-- เลือกคอลัมน์ --</option>${allHeaderOptions}`;
            metricSelect.innerHTML = `<option value="count">นับจำนวนแถว (Count)</option>${numericHeaderOptions}`;
            metricSelect.onchange = function() { aggregationContainer.style.display = this.value === 'count' ? 'none' : 'block'; };
            metricSelect.onchange();
            createChartModal.show();
        }

        function saveChart() {
            const form = getEl('create-chart-form');
            if (!form.checkValidity()) { form.classList.add('was-validated'); return; }
            userCharts.push({
                id: `chart-${Date.now()}`, title: getEl('chart-title').value, type: getEl('chart-type').value,
                groupBy: getEl('chart-group-by').value, metric: getEl('chart-metric').value, aggregation: getEl('chart-metric-aggregation').value
            });
            createChartModal.hide();
            saveStateToLocalStorage();
            renderAllCharts();
        }

        function renderAllCharts() {
            chartsContainer.innerHTML = '';
            if (userCharts.length === 0) { chartsContainer.appendChild(noChartsPlaceholder); noChartsPlaceholder.style.display = 'block'; return; }
            noChartsPlaceholder.style.display = 'none';

            userCharts.forEach(config => {
                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'col-lg-6 mb-4';
                chartWrapper.innerHTML = `<div class="card"><div class="card-header d-flex justify-content-between align-items-center"><span>${config.title}</span><button class="btn btn-sm btn-outline-light rounded-circle" data-chart-id="${config.id}" title="ลบกราฟ"><i class="bi bi-x-lg"></i></button></div><div class="card-body"><div class="chart-container" style="height: 400px;"><canvas id="${config.id}"></canvas></div></div></div>`;
                chartsContainer.appendChild(chartWrapper);
                renderChart(config);
            });
            chartsContainer.querySelectorAll('[data-chart-id]').forEach(btn => btn.addEventListener('click', (e) => {
                const chartId = e.currentTarget.dataset.chartId;
                userCharts = userCharts.filter(c => c.id !== chartId);
                if (chartInstances[chartId]) { chartInstances[chartId].destroy(); delete chartInstances[chartId]; }
                saveStateToLocalStorage();
                renderAllCharts();
            }));
        }

        function renderChart(config) {
            const data = filteredData;
            let chartData;
            if (config.metric === 'count') {
                const counts = data.reduce((acc, row) => { const key = row[config.groupBy] || 'N/A'; acc[key] = (acc[key] || 0) + 1; return acc; }, {});
                chartData = { labels: Object.keys(counts), values: Object.values(counts) };
            } else {
                const metrics = data.reduce((acc, row) => {
                    const key = row[config.groupBy] || 'N/A';
                    if (!acc[key]) { acc[key] = { sum: 0, count: 0 }; }
                    acc[key].sum += row[config.metric] || 0;
                    acc[key].count += 1;
                    return acc;
                }, {});
                chartData = { labels: Object.keys(metrics), values: Object.values(metrics).map(m => config.aggregation === 'sum' ? m.sum : (m.sum / m.count)) };
            }

            const ctx = getEl(config.id).getContext('2d');
            if (chartInstances[config.id]) chartInstances[config.id].destroy();
            const isBarOrLine = ['bar', 'line'].includes(config.type);
            
            chartInstances[config.id] = new Chart(ctx, {
                type: config.type,
                data: {
                    labels: chartData.labels,
                    datasets: [{ label: config.title, data: chartData.values, backgroundColor: isBarOrLine ? 'rgba(0, 123, 255, 0.7)' : ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6610f2', '#fd7e14'], borderColor: 'rgba(0, 123, 255, 1)', fill: config.type === 'line' }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: !isBarOrLine },
                        tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } let val = context.parsed.y ?? context.parsed; label += val.toLocaleString(undefined, { maximumFractionDigits: 2 }); return label; } } },
                        datalabels: { display: false }
                    },
                    scales: { x: { display: isBarOrLine }, y: { display: isBarOrLine } }
                }
            });
        }
        
        function getConfigurationObject() { return { headers, userKPIs, userCharts, activeFilters }; }
        function applyConfiguration(config) {
            userKPIs = config.userKPIs || [];
            userCharts = config.userCharts || [];
            activeFilters = config.activeFilters || [];
            filterBuilderContainer.innerHTML = '';
            activeFilters.forEach(filter => addFilterRow(filter));
            applyFiltersAndRender();
        }
        function getLocalStorageKey() { return `analyzerConfig_${currentFileName}_${currentSheetName}`; }
        function saveStateToLocalStorage() { try { localStorage.setItem(getLocalStorageKey(), JSON.stringify(getConfigurationObject())); } catch (e) { console.error("Error saving state", e); } }
        function loadStateFromLocalStorage() { try { const state = localStorage.getItem(getLocalStorageKey()); return state ? JSON.parse(state) : null; } catch (e) { console.error("Error loading state", e); return null; } }
        function clearLocalStorage() { if (confirm('คุณแน่ใจหรือไม่ว่าต้องการลบการตั้งค่าที่บันทึกไว้ในเครื่องนี้?')) { localStorage.removeItem(getLocalStorageKey()); alert('ลบการตั้งค่าแล้ว'); window.location.reload(); } }
        function saveConfigToFile() {
            const blob = new Blob([JSON.stringify(getConfigurationObject(), null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `analyzer_config_${currentFileName}_${currentSheetName}.json`;
            a.click(); URL.revokeObjectURL(a.href);
        }
        function loadConfigFromFile(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    if (config && Array.isArray(config.headers) && Array.isArray(config.userKPIs)) {
                        headers = config.headers.filter(h => allHeaders.includes(h));
                        if (headers.length === 0) { alert('ไฟล์การตั้งค่าไม่มีคอลัมน์ที่ตรงกับข้อมูลปัจจุบัน'); return; }
                        originalData = fullOriginalData.map(fullRow => { const newRow = {}; headers.forEach(h => { newRow[h] = fullRow[h]; }); return newRow; });
                        detectNumericHeaders();
                        convertNumericColumns();
                        renderTableHeader(); applyConfiguration(config); saveStateToLocalStorage();
                        alert('นำเข้าการตั้งค่าสำเร็จ');
                    } else { alert('ไฟล์การตั้งค่าไม่ถูกต้อง'); }
                } catch (err) { alert('เกิดข้อผิดพลาดในการอ่านไฟล์'); console.error(err); }
            };
            reader.readAsText(file); event.target.value = '';
        }

        function exportTableToCSV() {
            if (filteredData.length === 0) { alert("ไม่มีข้อมูลให้ส่งออก"); return; }
            const escapeCSV = (value) => { const str = String(value ?? ''); if (str.includes(',') || str.includes('"') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`; return str; };
            const csvRows = [headers.join(','), ...filteredData.map(row => headers.map(header => escapeCSV(row[header])).join(','))];
            const blob = new Blob([`\uFEFF${csvRows.join('\n')}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.download = `data_export_${currentFileName}_${currentSheetName}.csv`;
            link.click(); URL.revokeObjectURL(link.href);
        }
        async function exportDashboardToPDF() {
            const { jsPDF } = window.jspdf;
            const exportArea = getEl('pdf-export-area'), actions = getEl('dashboard-actions'), pdfButton = getEl('export-pdf-btn');
            const originalButtonText = pdfButton.innerHTML;
            pdfButton.disabled = true; pdfButton.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>กำลังสร้าง...`; actions.style.visibility = 'hidden';
            try {
                const canvas = await html2canvas(exportArea, { scale: 2, useCORS: true });
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
                pdf.setFont('Sarabun-Regular');
                const pdfWidth = pdf.internal.pageSize.getWidth(), pdfHeight = pdf.internal.pageSize.getHeight();
                const imgWidth = pdfWidth - 20, imgHeight = (canvas.height * imgWidth) / canvas.width;
                pdf.addImage(imgData, 'PNG', 10, 10, imgWidth, imgHeight);
                pdf.save(`dashboard_export_${currentFileName}_${currentSheetName}.pdf`);
            } catch (err) { console.error("PDF Export Error: ", err); alert("เกิดข้อผิดพลาดในการสร้าง PDF"); } 
            finally { actions.style.visibility = 'visible'; pdfButton.disabled = false; pdfButton.innerHTML = originalButtonText; }
        }

        function init() {
            Chart.register(ChartDataLabels);
            Chart.defaults.font.family = "'Sarabun', sans-serif";

            sheetSelectModal = new bootstrap.Modal(getEl('sheet-select-modal'));
            headerConfigModal = new bootstrap.Modal(getEl('header-config-modal'));
            kpiModal = new bootstrap.Modal(getEl('kpi-modal'));
            createChartModal = new bootstrap.Modal(getEl('create-chart-modal'));
            templateSelectModal = new bootstrap.Modal(getEl('template-select-modal'));

            getEl('footer-text').innerHTML = `Chatrium © ${new Date().getFullYear()}`;

            excelInput.addEventListener('change', handleFileSelection);
            getEl('upload-new-button').addEventListener('click', () => { window.location.reload(); });
            getEl('add-filter-btn').addEventListener('click', () => addFilterRow());
            getEl('create-kpi-btn').addEventListener('click', openCreateKpiModal);
            getEl('save-kpi-button').addEventListener('click', saveKpi);
            getEl('create-chart-btn').addEventListener('click', openCreateChartModal);
            getEl('save-chart-button').addEventListener('click', saveChart);
            
            getEl('process-selected-sheets-btn').addEventListener('click', () => {
                const selectedSheets = Array.from(getEl('sheet-list').querySelectorAll('input:checked')).map(cb => cb.value);
                if (selectedSheets.length === 0) {
                    alert('กรุณาเลือกอย่างน้อยหนึ่งชีต');
                    return;
                }
                processAndStoreSheets(selectedSheets);
            });

            getEl('next-header-config-btn').addEventListener('click', processCurrentSheetConfiguration);
            
            getEl('start-from-scratch-button').addEventListener('click', () => {
                templateSelectModal.hide();
                startHeaderConfigurationFlow(Object.keys(workbookDataStore));
            });

            getEl('save-config-btn').addEventListener('click', saveConfigToFile);
            getEl('load-config-btn').addEventListener('click', () => getEl('load-config-input').click());
            getEl('load-config-input').addEventListener('change', loadConfigFromFile);
            
            // Toggle Excel format mode
            getEl('toggle-excel-format-btn').addEventListener('click', (e) => {
                e.preventDefault();
                isExcelFormatEnabled = !isExcelFormatEnabled;
                const statusElement = getEl('excel-format-status');
                if (isExcelFormatEnabled) {
                    statusElement.textContent = 'เปิด';
                    statusElement.className = 'badge bg-success ms-2';
                } else {
                    statusElement.textContent = 'ปิด';
                    statusElement.className = 'badge bg-secondary ms-2';
                }
                // รีเฟรช table ใหม่
                if (filteredData && filteredData.length > 0) {
                    renderTableHeader();
                    renderTableBody();
                }
            });
            getEl('clear-storage-btn').addEventListener('click', clearLocalStorage);
            getEl('export-csv-btn').addEventListener('click', exportTableToCSV);
            getEl('export-pdf-btn').addEventListener('click', exportDashboardToPDF);

            tableHeaderEl.addEventListener('click', (e) => {
                const header = e.target.closest('th');
                if (!header || !header.dataset.sortKey) return;
                const newSortKey = header.dataset.sortKey;
                sortDir = sortKey === newSortKey ? (sortDir === 'asc' ? 'desc' : 'asc') : 'asc';
                sortKey = newSortKey;
                sortData();
                renderTableBody();
            });
        }
        
        init();
    </script>
</body>
</html>