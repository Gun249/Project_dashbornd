<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Dynamic</title>
    
    <!-- CSS Libraries -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    
    <!-- Custom Styles -->
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Sarabun', sans-serif;
            color: #343a40;
        }
        .upload-container {
            max-width: 700px; margin: 5rem auto; padding: 2.5rem;
            background-color: #ffffff; border-radius: 1rem;
            box-shadow: 0 8px 25px rgba(0,0,0,.07);
            text-align: center; border: 1px solid #dee2e6;
        }
        .card {
            border: none;
            box-shadow: 0 8px 25px rgba(0,0,0,.05);
            border-radius: 1rem; height: 100%;
        }
        .card-header {
            background: linear-gradient(to right, #007bff, #0056b3);
            color: white; font-weight: bold; border-top-left-radius: 1rem;
            border-top-right-radius: 1rem; border-bottom: none; padding: 1rem 1.5rem;
        }
        .kpi-card .card-body { transition: transform 0.2s, box-shadow 0.2s; }
        .kpi-card:hover .card-body { transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,.1); }
        .chart-container { position: relative; width: 100%; }
        .form-select:focus, .form-control:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.25rem rgba(0, 123, 255, 0.25);
        }
        .sortable-header { cursor: pointer; user-select: none; }
        .sortable-header:hover { background-color: #e9ecef; }
        .sort-asc::after { content: ' ‚ñ≤'; font-size: 0.8em; }
        .sort-desc::after { content: ' ‚ñº'; font-size: 0.8em; }
        .filter-row {
            background-color: #f1f3f5;
            border-radius: 0.5rem;
        }
        .header-select-list, #sheet-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .border-dashed {
            border: 2px dashed #dee2e6 !important;
        }
        .template-card {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
        }
        .template-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,.1);
            border-color: #007bff !important;
        }
        .chart-preview-container {
            height: 150px;
            position: relative;
        }
        
        /* Excel-like table styling */
        .table {
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            font-family: 'Sarabun', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .table th, .table td {
            border: 1px solid #d0d7de;
            padding: 6px 12px;
            margin: 0;
            line-height: 1.4;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
            min-width: 100px;
        }
        
        .table th {
            background: linear-gradient(to bottom, #f8f9fa 0%, #e9ecef 100%);
            font-weight: 600;
            border-bottom: 2px solid #d0d7de;
            position: sticky;
            top: 0;
            z-index: 10;
            text-align: center;
            color: #495057;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .table tbody tr {
            transition: background-color 0.15s ease;
        }
        
        .table tbody tr:hover {
            background-color: #f1f8ff !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .table tbody tr:nth-child(even) {
            background-color: #fafbfc;
        }
        
        .table tbody tr:nth-child(odd) {
            background-color: #ffffff;
        }
        
        .table-responsive {
            border: 1px solid #d0d7de;
            border-radius: 8px;
            overflow: auto;
            max-height: 600px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        /* Excel number formatting */
        .excel-number {
            text-align: right;
            font-family: 'SF Mono', Consolas, Monaco, 'Lucida Console', monospace;
            font-variant-numeric: tabular-nums;
            color: #0969da;
        }
        
        .excel-date {
            text-align: center;
            color: #8250df;
        }
        
        .excel-text {
            text-align: left;
            color: #24292f;
        }
        
        /* Sort indicators and month column styling */
        .sortable-header {
            transition: all 0.2s ease;
        }
        
        .sortable-header:hover .sort-icon {
            opacity: 1 !important;
            transform: scale(1.1);
        }
        
        .sort-icon {
            transition: all 0.2s ease;
            font-size: 12px;
        }
        
        .sortable-header[data-sort-key]:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Month column indicator */
        .bi-calendar3 {
            font-size: 11px;
        }

        /* Sort indicators */
        .sortable-header:hover {
            background: linear-gradient(to bottom, #e9ecef 0%, #dee2e6 100%) !important;
            transform: translateY(-1px);
        }
        
        .sort-asc::after {
            content: ' ‚ñ≤';
            font-size: 0.8em;
            color: #0969da;
            margin-left: 4px;
        }
        
        .sort-desc::after {
            content: ' ‚ñº';
            font-size: 0.8em;
            color: #0969da;
            margin-left: 4px;
        }
        
        /* Cell animations */
        .table td {
            transition: all 0.2s ease;
        }
        
        .table td:hover {
            background-color: #f1f8ff;
            transform: scale(1.02);
            z-index: 5;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>

    <div class="container-fluid p-4">
        
        <!-- Upload View -->
        <div id="upload-view">
            <div class="upload-container">
                <h1 class="mb-3">Dashboard Dynamic</h1>
                <p class="text-muted">‡πÇ‡∏õ‡∏£‡∏î‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</p>
                <hr class="my-4">
                <input type="file" id="excel-input" class="form-control form-control-lg" accept=".xlsx, .xls, .csv">
                <div id="loading-spinner" class="text-center mt-4" style="display: none;">
                    <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
                    <p class="mt-2" id="loading-status">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>
                </div>
                <div id="upload-error" class="text-danger mt-3"></div>
            </div>
        </div>

        <!-- Dashboard View -->
        <div id="dashboard-view" class="d-none">
            <div id="pdf-export-area">
                <header class="mb-4 d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3">
                    <div>
                        <h1 class="mb-0">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</h1>
                        <!-- Sheet switcher will be placed here -->
                        <div id="sheet-switcher-container" class="mt-2"></div>
                        <p id="file-info" class="text-muted small mt-1">‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
                    </div>
                    <div class="d-flex gap-2 flex-wrap justify-content-end" id="dashboard-actions">
                        <button id="create-kpi-btn" class="btn btn-info text-white"><i class="bi bi-calculator-fill me-2"></i>‡∏™‡∏£‡πâ‡∏≤‡∏á KPI</button>
                        <button id="create-chart-btn" class="btn btn-primary"><i class="bi bi-plus-circle-dotted me-2"></i>‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü</button>
                        
                        <div class="dropdown">
                            <button class="btn btn-secondary dropdown-toggle" type="button" id="settingsMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="bi bi-gear-fill me-1"></i> ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="settingsMenuButton">
                                <li><a class="dropdown-item" href="#" id="save-config-btn"><i class="bi bi-download me-2"></i>‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (‡πÑ‡∏ü‡∏•‡πå)</a></li>
                                <li><a class="dropdown-item" href="#" id="load-config-btn"><i class="bi bi-upload me-2"></i>‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (‡πÑ‡∏ü‡∏•‡πå)</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" id="export-csv-btn"><i class="bi bi-file-earmark-spreadsheet-fill me-2"></i>‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô CSV</a></li>
                                <li><a class="dropdown-item" href="#" id="export-pdf-btn"><i class="bi bi-file-earmark-pdf-fill me-2"></i>‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô PDF</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item text-info" href="#" id="debug-data-btn"><i class="bi bi-bug-fill me-2"></i>‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Debug (Console)</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item text-danger" href="#" id="clear-storage-btn"><i class="bi bi-trash3-fill me-2"></i>‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ (‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)</a></li>
                            </ul>
                        </div>
                        <input type="file" id="load-config-input" class="d-none" accept=".json">

                        <button id="upload-new-button" class="btn btn-outline-secondary"><i class="bi bi-arrow-clockwise me-2"></i>‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà</button>
                    </div>
                </header>

                <!-- KPIs Section -->
                <div id="kpis-container" class="row mb-4">
                     <div id="no-kpis-placeholder" class="col-12 text-center text-muted py-4">
                        <div class="card p-4 bg-light border-dashed">
                            <i class="bi bi-calculator fs-1"></i>
                            <h5 class="mt-3">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ KPI</h5>
                            <p class="mb-0">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡∏∏‡πà‡∏° "‡∏™‡∏£‡πâ‡∏≤‡∏á KPI" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ä‡∏µ‡πâ‡∏ß‡∏±‡∏î</p>
                        </div>
                    </div>
                </div>

                <!-- Charts Section -->
                <div id="charts-container" class="row mb-4">
                     <div id="no-charts-placeholder" class="col-12 text-center text-muted py-4">
                        <div class="card p-4 bg-light border-dashed">
                            <i class="bi bi-bar-chart-line fs-1"></i>
                            <h5 class="mt-3">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏£‡∏≤‡∏ü</h5>
                            <p class="mb-0">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡∏∏‡πà‡∏° "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Filter & Data Table Section -->
            <div class="card">
                <div class="card-body p-4">
                    <h5 class="card-title mb-3">‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Filters)</h5>
                    <div id="filter-builder-container" class="mb-4">
                        <!-- Dynamic filters will be added here -->
                    </div>
                    <button id="add-filter-btn" class="btn btn-outline-primary btn-sm"><i class="bi bi-plus-lg me-1"></i> ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏¥‡∏•‡πÄ‡∏ï‡∏≠‡∏£‡πå</button>
                    <hr>
                    <h5 class="card-title mb-3">‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</h5>
                    
                    <!-- Table Controls -->
                    <div class="d-flex justify-content-between align-items-center mb-3 flex-column flex-md-row gap-3">
                        <div class="d-flex align-items-center gap-2">
                            <label for="rows-per-page-select" class="col-form-label col-form-label-sm">‡πÅ‡∏™‡∏î‡∏á</label>
                            <select id="rows-per-page-select" class="form-select form-select-sm" style="width: 75px;">
                                <option value="15" selected>15</option>
                                <option value="25">25</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                            </select>
                            <span class="col-form-label col-form-label-sm">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</span>
                        </div>
                        <div id="pagination-controls"></div>
                    </div>

                    <div class="table-responsive">
                        <table class="table table-striped table-hover">
                            <thead id="data-table-header"></thead>
                            <tbody id="data-table-body"></tbody>
                        </table>
                        <div id="no-results" class="text-center py-5 text-muted d-none"><p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç</p></div>
                    </div>
                </div>
            </div>
            
            <footer class="text-center text-sm text-muted mt-5"><p id="footer-text">Chatrium¬© 2024</p></footer>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal fade" id="sheet-select-modal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header"><h5 class="modal-title">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ô‡∏≥‡∏°‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</h5></div>
          <div class="modal-body">
            <p class="text-muted">‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏µ‡∏ï ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏µ‡∏ï)</p>
            <div id="sheet-list" class="list-group">
                <!-- Checkboxes will be injected here -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" id="process-selected-sheets-btn">‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠</button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal fade" id="template-select-modal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå (Template)</h5>
          </div>
          <div class="modal-body">
            <p class="text-muted">‡πÄ‡∏£‡∏≤‡πÑ‡∏î‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏®‡∏π‡∏ô‡∏¢‡πå" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</p>
            <div id="template-card-container" class="row g-3 mt-2">
                <!-- Template cards will be injected here by JavaScript -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-outline-secondary" id="start-from-scratch-button">
                <i class="bi bi-tools me-2"></i>‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏®‡∏π‡∏ô‡∏¢‡πå (‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏≠‡∏á)
            </button>
          </div>
        </div>
      </div>
    </div>


    <!-- New Multi-Sheet Header Configuration Modal -->
    <div class="modal fade" id="header-config-modal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="header-config-modal-title">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå</h5>
          </div>
          <div class="modal-body">
            <p class="text-muted">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏µ‡∏ï‡∏ô‡∏µ‡πâ</p>
            <div id="header-config-list" class="list-group header-select-list">
                <!-- Header checkboxes will be injected here -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" id="next-header-config-btn">Next Sheet</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="kpi-modal" tabindex="-1" aria-labelledby="kpiModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header"><h5 class="modal-title" id="kpiModalLabel">‡∏™‡∏£‡πâ‡∏≤‡∏á KPI ‡πÉ‡∏´‡∏°‡πà</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div>
                <div class="modal-body">
                    <form id="create-kpi-form">
                        <div class="mb-3"><label for="kpi-title" class="form-label">‡∏ä‡∏∑‡πà‡∏≠ KPI</label><input type="text" class="form-control" id="kpi-title" required></div>
                        <div class="mb-3"><label for="kpi-calculation" class="form-label">‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì</label><select class="form-select" id="kpi-calculation" required></select></div>
                        <div class="mb-3" id="kpi-column-container"><label for="kpi-column" class="form-label">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå</label><select class="form-select" id="kpi-column" required></select></div>
                    </form>
                </div>
                <div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">‡∏õ‡∏¥‡∏î</button><button type="button" class="btn btn-primary" id="save-kpi-button">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å KPI</button></div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="create-chart-modal" tabindex="-1" aria-labelledby="createChartModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header"><h5 class="modal-title" id="createChartModalLabel">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÉ‡∏´‡∏°‡πà</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div>
          <div class="modal-body">
            <form id="create-chart-form">
              <div class="mb-3"><label for="chart-title" class="form-label">‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏≤‡∏ü</label><input type="text" class="form-control" id="chart-title" required></div>
              <div class="mb-3"><label for="chart-type" class="form-label">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏£‡∏≤‡∏ü</label><select class="form-select" id="chart-type"><option value="bar">‡∏Å‡∏£‡∏≤‡∏ü‡πÅ‡∏ó‡πà‡∏á (Bar)</option><option value="pie">‡∏Å‡∏£‡∏≤‡∏ü‡∏ß‡∏á‡∏Å‡∏•‡∏° (Pie)</option><option value="doughnut">‡∏Å‡∏£‡∏≤‡∏ü‡πÇ‡∏î‡∏ô‡∏±‡∏ó (Doughnut)</option><option value="line">‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏™‡πâ‡∏ô (Line)</option></select></div>
              <div class="mb-3"><label for="chart-group-by" class="form-label">‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢ (Group By)</label><select class="form-select" id="chart-group-by" required></select></div>
              <div class="mb-3"><label for="chart-metric" class="form-label">‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏î (Measure)</label><select class="form-select" id="chart-metric" required></select></div>
              <div class="mb-3" id="metric-aggregation-container"><label for="chart-metric-aggregation" class="form-label">‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì</label><select class="form-select" id="chart-metric-aggregation"><option value="sum">‡∏ú‡∏•‡∏£‡∏ß‡∏° (Sum)</option><option value="average">‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (Average)</option></select></div>
            </form>
          </div>
          <div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">‡∏õ‡∏¥‡∏î</button><button type="button" class="btn btn-primary" id="save-chart-button">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏£‡∏≤‡∏ü</button></div>
        </div>
      </div>
    </div>


    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/parn-pon/thaifont-jspdf/Sarabun-Regular-normal.js"></script>


    <!-- Main Application Script -->
    <script>
        // --- GLOBAL STATE ---
        let fullOriginalData = [];
        let originalData = [];
        let filteredData = [];
        let allHeaders = [];
        let headers = [];
        let numericHeaders = [];
        let activeFilters = [];
        let userKPIs = [];
        let userCharts = [];
        let chartInstances = {};
        let workbook;
        let workbookDataStore = {};
        let currentFileName = '';
        let currentSheetName = '';
        let currentPage = 1;
        let rowsPerPage = 15;
        let sortKey = '';
        let sortDir = 'asc';
        
        let sheetSelectModal, headerConfigModal, kpiModal, createChartModal, templateSelectModal;
        
        // --- State for Header Configuration Flow ---
        let sheetsToConfigure = [];
        let currentConfigSheetIndex = 0;


        // --- DOM ELEMENTS ---
        const getEl = (id) => document.getElementById(id);
        const uploadView = getEl('upload-view');
        const dashboardView = getEl('dashboard-view');
        const excelInput = getEl('excel-input');
        const loadingSpinner = getEl('loading-spinner');
        const loadingStatusEl = getEl('loading-status');
        const uploadErrorEl = getEl('upload-error');
        const fileInfoEl = getEl('file-info');
        const sheetList = getEl('sheet-list');
        const tableHeaderEl = getEl('data-table-header');
        const tableBodyEl = getEl('data-table-body');
        const noResultsEl = getEl('no-results');
        const paginationControls = getEl('pagination-controls');
        const filterBuilderContainer = getEl('filter-builder-container');
        const kpisContainer = getEl('kpis-container');
        const noKpisPlaceholder = getEl('no-kpis-placeholder');
        const chartsContainer = getEl('charts-container');
        const noChartsPlaceholder = getEl('no-charts-placeholder');

        // --- FILE & DATA LOADING ---

        function handleFileSelection(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                // Validate file type
                if (!file.name.match(/\.(xlsx?|csv)$/i)) {
                    uploadErrorEl.textContent = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏´‡∏£‡∏∑‡∏≠ CSV ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô";
                    return;
                }
                
                // Validate file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    uploadErrorEl.textContent = "‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10MB)";
                    return;
                }
                
                currentFileName = file.name;
                loadingSpinner.style.display = 'block';
                uploadErrorEl.textContent = '';
                loadingStatusEl.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå...';
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                         setTimeout(() => {
                            try {
                                workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array', cellDates: false });
                                
                                if (!workbook || !workbook.SheetNames || workbook.SheetNames.length === 0) {
                                    throw new Error("‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏µ‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢");
                                }

                                if (workbook.SheetNames.length === 1) {
                                    processAndStoreSheets([workbook.SheetNames[0]]);
                                } else {
                                    const sheetListContainer = getEl('sheet-list');
                                    sheetListContainer.innerHTML = '';
                                    workbook.SheetNames.forEach(name => {
                                        const item = document.createElement('label');
                                        item.className = 'list-group-item';
                                        item.innerHTML = `<input class="form-check-input me-2" type="checkbox" value="${name}" checked> ${name}`;
                                        sheetListContainer.appendChild(item);
                                    });
                                    loadingSpinner.style.display = 'none';
                                    sheetSelectModal.show();
                                }
                            } catch (error) {
                                uploadErrorEl.textContent = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå: " + error.message;
                                loadingSpinner.style.display = 'none';
                            }
                        }, 10);
                    } catch (error) {
                        uploadErrorEl.textContent = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå: " + error.message;
                        loadingSpinner.style.display = 'none';
                    }
                };
                reader.onerror = () => { 
                    uploadErrorEl.textContent = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"; 
                    loadingSpinner.style.display = 'none';
                };
                reader.readAsArrayBuffer(file);
                excelInput.value = '';
            } catch (error) {
                uploadErrorEl.textContent = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå: " + error.message;
                loadingSpinner.style.display = 'none';
            }
        }

        /**
         * Parses a sheet with a complex, multi-level HR report structure.
         * @param {Array<Array<any>>} sheetData - Raw data from the sheet.
         * @param {string|null} fileYear - The year extracted from the filename, for defaulting.
         * @returns {{data: Array<Object>, headers: Array<string>}} - The parsed flat data and its headers.
         */
        function parseHrReportData(sheetData, fileYear = null) {
            try {
                if (!sheetData || !Array.isArray(sheetData) || sheetData.length === 0) {
                    throw new Error("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ä‡∏µ‡∏ï‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤");
                }

                const structuredData = [];
                const finalHeaders = ['department', 'hotel', 'type', 'period', 'value'];

                // --- Constants for identifying rows and columns ---
                const HOTEL_CODES = ['CHRB', 'CRRB', 'CRST', 'ES', 'CGB', 'MHSC', 'MHRB', 'MMSB', 'SDAO', 'LKYT', 'CHRY', 'CNSJ', 'CHH'];
                const EMPLOYMENT_TYPES = ['FT', 'CT', 'OS'];
                const STAFFING_DEPARTMENTS = ['FO', 'HKP', 'Laundry', 'Fitness', 'F&B Service', 'Kitchen', 'A&G', 'Finance', 'Procurement', 'IT', 'HR', 'Security', 'Sales', 'Engineering', 'MarComm', 'E-Commerce', 'Commercial', 'Service Quality Assurance', 'Golf Operations', 'Golf Maintenance'];
                const STAFFING_DEPARTMENT_SET = new Set(STAFFING_DEPARTMENTS.map(dept => dept.toUpperCase()));

                console.log(`üîç Looking for hotel codes:`, HOTEL_CODES);

                let hotelRowIndex = -1, typeRowIndex = -1, periodRowIndex = -1;
                const upperHotelCodes = HOTEL_CODES.map(c => c.toUpperCase());

                // --- Find the key header rows ---
                const searchLimit = Math.min(sheetData.length, 20);
                for (let i = 0; i < searchLimit; i++) {
                    try {
                        const row = sheetData[i] || [];
                        
                        // Debug each row to see what we find
                        const rowValues = row.slice(0, 15).map(cell => String(cell || '').trim()).filter(v => v);
                        if (rowValues.length > 0) {
                            console.log(`Row ${i}:`, rowValues);
                        }
                        
                        if (hotelRowIndex === -1 && row.some(cell => upperHotelCodes.includes(String(cell || '').trim().toUpperCase()))) {
                            hotelRowIndex = i;
                            console.log(`üè® Hotel row found at index ${i}:`, row.slice(0, 15));
                        }
                        if (typeRowIndex === -1 && row.some(cell => EMPLOYMENT_TYPES.includes(String(cell || '').trim().toUpperCase()))) {
                            typeRowIndex = i;
                            console.log(`üë• Type row found at index ${i}:`, row.slice(0, 15));
                        }
                        
                        // Use a more robust check for the period row
                        let dateLikeCount = row.filter(cell => formatPeriod(cell, fileYear)).length;
                        if (periodRowIndex === -1 && dateLikeCount > 2) { // Require at least 3 date-like cells
                            periodRowIndex = i;
                            console.log(`üìÖ Period row found at index ${i} with ${dateLikeCount} date-like cells:`, row.slice(0, 15));
                        }
                    } catch (error) {
                        console.warn(`Error processing row ${i}:`, error);
                        continue;
                    }
                }

                console.log(`üìç Header rows found - Hotel: ${hotelRowIndex}, Type: ${typeRowIndex}, Period: ${periodRowIndex}`);

                // Validate that all required header rows were found
                if (hotelRowIndex === -1 || typeRowIndex === -1 || periodRowIndex === -1) {
                    throw new Error("HR Parser: Could not find required header rows (Hotel, Type, or Period).");
                }

                // --- Build a context map for each column ---
                const columnContextMap = new Map();
                const hotelRow = sheetData[hotelRowIndex];
                const typeRow = sheetData[typeRowIndex];
                const periodRow = sheetData[periodRowIndex];
                const maxCols = Math.max((hotelRow || []).length, (typeRow || []).length, (periodRow || []).length);

                // Helper to find the last valid value in a row, simulating merged cells
                const findLastValidValue = (row, colIndex, validSet) => {
                    try {
                        for (let k = colIndex; k >= 0; k--) {
                            const cellValue = String((row || [])[k] || '').trim().toUpperCase();
                            const foundValue = validSet.find(v => v.toUpperCase() === cellValue);
                            if (foundValue) return foundValue;
                        }
                        return null;
                    } catch (error) {
                        console.warn('Error in findLastValidValue:', error);
                        return null;
                    }
                };

                for (let j = 1; j < maxCols; j++) {
                    try {
                        const currentHotel = findLastValidValue(hotelRow, j, HOTEL_CODES);
                        const currentType = findLastValidValue(typeRow, j, EMPLOYMENT_TYPES);
                        const formattedPeriod = formatPeriod(periodRow[j], fileYear);

                        // Debug logging ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ column
                        if (j <= 15) { // Debug ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ 15 columns ‡πÅ‡∏£‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ log ‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                            console.log(`Column ${j}:`, {
                                hotel: currentHotel,
                                type: currentType,
                                period: formattedPeriod,
                                hotelCell: hotelRow?.[j],
                                typeCell: typeRow?.[j],
                                periodCell: periodRow?.[j]
                            });
                        }

                        // Store context only if all three components are found
                        if (currentHotel && currentType && formattedPeriod) {
                            columnContextMap.set(j, { hotel: currentHotel, type: currentType, period: formattedPeriod });
                        }
                    } catch (error) {
                        console.warn(`Error processing column ${j}:`, error);
                        continue;
                    }
                }

                console.log(`üìç Total columns mapped: ${columnContextMap.size} out of ${maxCols - 1}`);
                console.log(`üìç Mapped columns:`, Array.from(columnContextMap.entries()).map(([col, ctx]) => `${col}: ${ctx.hotel}-${ctx.type}-${ctx.period}`));

                // --- Iterate through data rows and create flat records ---
                const dataStartIndex = periodRowIndex + 1;
                console.log(`üìç Starting data processing from row ${dataStartIndex}`);
                
                for (let i = dataStartIndex; i < sheetData.length; i++) {
                    try {
                        const row = sheetData[i] || [];
                        const rawDeptName = String(row[0] || '').trim();
                        
                        if (!rawDeptName || rawDeptName.toUpperCase().includes('TOTAL')) continue;
                        
                        // Check if this department is one we care about for staffing
                        const normalizedDeptName = rawDeptName.toUpperCase().replace(/[^A-Z0-9]/g, '');
                        const shouldProcessRow = STAFFING_DEPARTMENT_SET.has(normalizedDeptName) || 
                                               STAFFING_DEPARTMENTS.some(dept => 
                                                   normalizedDeptName.includes(dept.toUpperCase().replace(/[^A-Z0-9]/g, ''))
                                               );
                        
                        if (shouldProcessRow) {
                            let rowDataCount = 0;
                            columnContextMap.forEach((context, colIndex) => {
                                try {
                                    const cellValue = row[colIndex];
                                    if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                                        const numericValue = parseFloat(String(cellValue).replace(/,/g, ''));
                                        if (!isNaN(numericValue) && isFinite(numericValue)) {
                                            structuredData.push({
                                                department: rawDeptName,
                                                hotel: context.hotel,
                                                type: context.type,
                                                period: context.period,
                                                value: numericValue
                                            });
                                            rowDataCount++;
                                            
                                            // Debug specific LKYT data
                                            if (context.hotel === 'LKYT') {
                                                console.log(`üè® LKYT Data found:`, {
                                                    department: rawDeptName,
                                                    hotel: context.hotel,
                                                    type: context.type,
                                                    period: context.period,
                                                    value: numericValue,
                                                    cellValue: cellValue,
                                                    row: i,
                                                    col: colIndex
                                                });
                                            }
                                        }
                                    }
                                } catch (error) {
                                    console.warn(`Error processing cell [${i}][${colIndex}]:`, error);
                                }
                            });
                            
                            if (rowDataCount > 0) {
                                console.log(`üìä Row ${i} (${rawDeptName}): processed ${rowDataCount} data points`);
                            }
                        }
                    } catch (error) {
                        console.warn(`Error processing data row ${i}:`, error);
                        continue;
                    }
                }
                
                if (structuredData.length === 0) {
                    throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö HR Report");
                }
                
                // Debug: ‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ
                const hotelSummary = {};
                structuredData.forEach(item => {
                    if (!hotelSummary[item.hotel]) {
                        hotelSummary[item.hotel] = 0;
                    }
                    hotelSummary[item.hotel]++;
                });
                
                console.log(`üìà Final structured data summary:`);
                console.log(`   Total records: ${structuredData.length}`);
                console.log(`   Hotels found:`, Object.keys(hotelSummary));
                console.log(`   Records per hotel:`, hotelSummary);
                console.log(`   LKYT records:`, hotelSummary['LKYT'] || 0);
                
                return { data: structuredData, headers: finalHeaders };
            } catch (error) {
                console.error('Error in parseHrReportData:', error);
                throw error;
            }
        }
        
        /**
         * Parses a generic sheet by finding the most likely header row.
         * @param {Array<Array<any>>} dataAsArray - Raw data from the sheet.
         * @returns {{data: Array<Object>, headers: Array<string>}} - The parsed flat data and its headers.
         */
        function parseGenericData(dataAsArray) {
            const headerRowIndex = findGenericHeaderRow(dataAsArray);
            if (headerRowIndex === -1) {
                throw new Error("Generic Parser: Could not find a valid header row.");
            }

            const rawHeaders = dataAsArray[headerRowIndex].filter(h => h && String(h).trim());
            const dataRows = dataAsArray.slice(headerRowIndex + 1);

            const jsonData = dataRows.map(row => {
                const obj = {};
                rawHeaders.forEach(header => {
                    const originalIndex = dataAsArray[headerRowIndex].indexOf(header);
                    obj[header] = row[originalIndex];
                });
                return obj;
            });
            
            const sanitizedHeaders = rawHeaders.map(h => 
                String(h).trim()
                         .replace(/[.\s-()\[\]{}]/g, '_')
                         .replace(/_+/g, '_')
            );
            
            const sheetData = [];
            jsonData.forEach(row => {
                const newRow = {};
                rawHeaders.forEach((originalHeader, i) => {
                    const sanitizedHeader = sanitizedHeaders[i];
                    newRow[sanitizedHeader] = row[originalHeader];
                });
                sheetData.push(newRow);
            });

            return { data: sheetData, headers: sanitizedHeaders };
        }

        /**
         * Analyzes sheet rows to find the most likely header row for generic tables.
         * @param {Array<Array<string>>} dataAsArray - The sheet data as an array of arrays.
         * @returns {number} The index of the detected header row.
         */
        function findGenericHeaderRow(dataAsArray) {
            let bestGuess = { index: -1, score: -Infinity };
            const searchLimit = Math.min(dataAsArray.length - 1, 25); 

            const profileRow = (row) => {
                let stringCount = 0, numberCount = 0;
                const nonEmptyCells = [];
                if (!row) return { stringCount, numberCount, nonEmptyCells };
                row.forEach(cell => {
                    const value = cell === null || cell === undefined ? '' : String(cell).trim();
                    if (value !== '') {
                        nonEmptyCells.push(value);
                        const cleanVal = value.replace(/[,\s‡∏ø$‚Ç¨¬£¬•]/g, '').replace(/^\((.+)\)$/, '-$1');
                        if (!isNaN(parseFloat(cleanVal)) && isFinite(cleanVal)) numberCount++;
                        else stringCount++;
                    }
                });
                return { stringCount, numberCount, nonEmptyCells };
            };

            for (let i = 0; i < searchLimit; i++) {
                const currentProfile = profileRow(dataAsArray[i]);
                const nextProfile = profileRow(dataAsArray[i + 1]);
                let score = 0;
                if (currentProfile.nonEmptyCells.length < 2 || nextProfile.nonEmptyCells.length === 0) continue;
                
                const stringRatio = currentProfile.stringCount / currentProfile.nonEmptyCells.length;
                score += stringRatio * 15;
                const numberRatio = currentProfile.numberCount / currentProfile.nonEmptyCells.length;
                score -= numberRatio * 10;
                score += currentProfile.nonEmptyCells.length * 1.5;
                const numberIncrease = nextProfile.numberCount - currentProfile.numberCount;
                if (numberIncrease > 0) score += numberIncrease * 8;
                const columnCountDifference = Math.abs(currentProfile.nonEmptyCells.length - nextProfile.nonEmptyCells.length);
                score -= columnCountDifference * 2;
                const uniqueness = new Set(currentProfile.nonEmptyCells).size / currentProfile.nonEmptyCells.length;
                score += uniqueness * 5;

                if (score > bestGuess.score) {
                    bestGuess.score = score;
                    bestGuess.index = i;
                }
            }
            return bestGuess.index === -1 ? 0 : bestGuess.index;
        }
        
        // --- NEW HELPER FUNCTION ---
        /**
         * Converts an Excel serial number to a JavaScript Date object.
         * @param {number} serial - The Excel serial number.
         * @returns {Date} The converted JavaScript Date object.
         */
        function excelSerialToDate(serial) {
            try {
                // Excel date system: January 1, 1900 is day 1 (serial = 1)
                // Excel incorrectly treats 1900 as a leap year, so we adjust for dates after Feb 28, 1900
                
                // For dates after Feb 28, 1900 (serial > 59), subtract 1 to correct Excel's leap year bug
                let daysSince1900 = serial > 59 ? serial - 1 : serial;
                
                // Excel epoch: January 1, 1900 00:00:00 local time
                const excelEpoch = new Date(1900, 0, 1);
                
                // Add the days (subtract 1 because Excel serial 1 = Jan 1, 1900, not Jan 2)
                const resultDate = new Date(excelEpoch.getTime() + (daysSince1900 - 1) * 86400000);
                
                // Validate the result
                if (isNaN(resultDate.getTime())) {
                    throw new Error(`Invalid date calculated from serial ${serial}`);
                }
                
                return resultDate;
            } catch (error) {
                console.error('Error converting Excel serial to date:', error);
                return new Date(); // Return current date as fallback
            }
        }

        /**
         * Parses a cell value into a "Mmm-YYYY" format. Returns null if invalid.
         * This version is stricter and handles numeric date serials manually.
         * @param {*} periodCell - The cell value to parse.
         * @param {string|null} defaultYear - The default year to use if not found in the cell.
         * @returns {string|null} The formatted period string or null.
         */
        function formatPeriod(periodCell, defaultYear = null) {
            try {
                if (periodCell === null || periodCell === undefined || String(periodCell).trim() === '') {
                    return null;
                }

                const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                // 1. Handle if the cell is a number (likely an Excel date serial)
                if (typeof periodCell === 'number') {
                    // Add a sanity check to avoid converting regular numbers like "2025". 
                    // Excel serial numbers for dates around this era are > 40000.
                    if (periodCell > 40000 && periodCell < 60000) { // Dates from ~2010 to ~2065
                        const date = excelSerialToDate(periodCell);
                        if (date && !isNaN(date.getTime())) {
                             const month = monthNames[date.getMonth()];
                             let year = date.getFullYear();
                             
                             // Override year if defaultYear is provided (from filename)
                             if (defaultYear) {
                                 year = parseInt(defaultYear) || year;
                             }
                             
                             return `${month}-${year}`;
                        }
                    }
                    return null;
                }

                // 2. Handle if it's already a JavaScript Date object
                if (periodCell instanceof Date) {
                    if (isNaN(periodCell.getTime())) {
                        return null;
                    }
                    const month = monthNames[periodCell.getMonth()];
                    const year = periodCell.getFullYear();
                    return `${month}-${year}`;
                }
                
                // 3. Handle if it's a string
                const periodRaw = String(periodCell).trim();

                // Handle DD/MM/YYYY format (Thai/European style - like 01/05/2025 = 1 May 2025)
                const dateMatch = periodRaw.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
                if (dateMatch) {
                    const day = parseInt(dateMatch[1], 10);
                    const month = parseInt(dateMatch[2], 10);    // Second number is month
                    const year = parseInt(dateMatch[3], 10);
                    
                    // Validate the date components
                    if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year > 1900 && year < 2100) {
                        const monthIndex = month - 1; // Convert to 0-based index
                        const monthName = monthNames[monthIndex];
                        return `${monthName}-${year}`;
                    }
                }

                // Handle month name patterns (including simple cases like "Jan", "Feb", etc.)
                const monthPattern = `^(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?|AVG|avg|Average|AVERAGE|Total|TOTAL)$`;
                const mainRegex = new RegExp(monthPattern, 'i');
                const match = periodRaw.match(mainRegex);

                if (match) {
                    const monthStr = match[1];
                    let month;
                    
                    // Handle special cases
                    if (monthStr.toLowerCase().includes('avg')) {
                        month = 'AVG';
                    } else if (monthStr.toLowerCase().includes('total')) {
                        month = 'Total';
                    } else {
                        month = monthStr.charAt(0).toUpperCase() + monthStr.slice(1, 3).toLowerCase();
                    }
                    
                    // Use defaultYear from filename if available, otherwise current year
                    const year = defaultYear || new Date().getFullYear();
                    return month === 'AVG' || month === 'Total' ? month : `${month}-${year}`;
                }

                return null;
            } catch (error) {
                console.error('Error in formatPeriod:', error);
                return null;
            }
        }

        function processAndStoreSheets(sheetNames) {
            try {
                if (!sheetNames || !Array.isArray(sheetNames) || sheetNames.length === 0) {
                    throw new Error("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ sheets ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•");
                }

                if (sheetSelectModal) sheetSelectModal.hide();
                loadingSpinner.style.display = 'block';
                uploadErrorEl.textContent = '';
                
                workbookDataStore = {};
                let processedSheetCount = 0;
                const yearMatch = currentFileName.match(/\b(20\d{2})\b/);
                const fileYear = yearMatch ? yearMatch[1] : null;
                const processingErrors = [];

                sheetNames.forEach(sheetName => {
                    try {
                        if (!sheetName || typeof sheetName !== 'string') {
                            throw new Error(`‡∏ä‡∏∑‡πà‡∏≠ sheet ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ${sheetName}`);
                        }

                        loadingStatusEl.textContent = `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏ä‡∏µ‡∏ï: ${sheetName}...`;
                        const ws = workbook.Sheets[sheetName];
                        if (!ws) {
                            throw new Error(`‡πÑ‡∏°‡πà‡∏û‡∏ö worksheet: ${sheetName}`);
                        }

                        const dataAsArray = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });
                        if (!Array.isArray(dataAsArray)) {
                            throw new Error(`‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å sheet "${sheetName}" ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà array`);
                        }
                        
                        if (dataAsArray.length < 5) {
                            console.warn(`Sheet "${sheetName}" ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (${dataAsArray.length} rows) - ‡∏Ç‡πâ‡∏≤‡∏°`);
                            return;
                        }

                        let parsedResult = null;
                        try {
                            const hrResult = parseHrReportData(dataAsArray, fileYear);
                            if (hrResult && hrResult.data && hrResult.data.length > 0) {
                                parsedResult = hrResult;
                            } else {
                                throw new Error("HR Parser found no data.");
                            }
                        } catch (hrError) {
                            console.warn(`HR Parser failed for sheet "${sheetName}", trying simple monthly parser. Reason: ${hrError.message}`);
                            try {
                                const simpleResult = parseSimpleMonthlyData(dataAsArray, fileYear);
                                if (simpleResult && simpleResult.data && simpleResult.data.length > 0) {
                                    parsedResult = simpleResult;
                                }
                            } catch (simpleError) {
                                console.warn(`Simple monthly parser failed for sheet "${sheetName}", falling back to generic parser. Reason: ${simpleError.message}`);
                                try {
                                    const genericResult = parseGenericData(dataAsArray);
                                    if (genericResult && genericResult.data && genericResult.data.length > 0) {
                                        parsedResult = genericResult;
                                    }
                                } catch (genericError) {
                                    console.error(`All parsers failed for sheet "${sheetName}":`, genericError);
                                    throw new Error(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å sheet "${sheetName}" ‡πÑ‡∏î‡πâ‡∏î‡πâ‡∏ß‡∏¢ parser ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î`);
                                }
                            }
                        }
                        
                        if (parsedResult) {
                            workbookDataStore[sheetName] = parsedResult;
                            processedSheetCount++;
                        }

                    } catch (error) {
                        const errorMsg = `Error processing sheet "${sheetName}": ${error.message}`;
                        console.error(errorMsg);
                        processingErrors.push(errorMsg);
                    }
                });

                if (processedSheetCount === 0) {
                    const errorDetail = processingErrors.length > 0 ? `\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: ${processingErrors.join('; ')}` : '';
                    throw new Error(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ä‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å${errorDetail}`);
                }
                
                if (processingErrors.length > 0) {
                    console.warn(`‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ ${processedSheetCount}/${sheetNames.length} sheets. Errors:`, processingErrors);
                }
                
                generateAndShowTemplates();

            } catch (error) {
                console.error('Error in processAndStoreSheets:', error);
                uploadErrorEl.textContent = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: " + error.message;
                loadingSpinner.style.display = 'none';
                throw error;
            }
        }

        function startHeaderConfigurationFlow(sheetNames) {
            sheetsToConfigure = sheetNames;
            currentConfigSheetIndex = 0;
            displaySheetForConfiguration();
            headerConfigModal.show();
        }

        function displaySheetForConfiguration() {
            const sheetName = sheetsToConfigure[currentConfigSheetIndex];
            getEl('header-config-modal-title').textContent = `‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö: ${sheetName}`;
            
            const listContainer = getEl('header-config-list');
            listContainer.innerHTML = '';
            const allPossibleHeaders = workbookDataStore[sheetName].headers;

            allPossibleHeaders.forEach(header => {
                const item = document.createElement('label');
                item.className = 'list-group-item';
                item.innerHTML = `<input class="form-check-input me-2" type="checkbox" value="${header}" checked> ${header}`;
                listContainer.appendChild(item);
            });

            const nextButton = getEl('next-header-config-btn');
            if (currentConfigSheetIndex >= sheetsToConfigure.length - 1) {
                nextButton.textContent = '‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô';
            } else {
                nextButton.textContent = '‡∏ä‡∏µ‡∏ï‡∏ñ‡∏±‡∏î‡πÑ‡∏õ';
            }
        }

        function processCurrentSheetConfiguration() {
            const sheetName = sheetsToConfigure[currentConfigSheetIndex];
            const selectedCheckboxes = getEl('header-config-list').querySelectorAll('input:checked');
            const selectedHeaders = Array.from(selectedCheckboxes).map(cb => cb.value);

            if (selectedHeaders.length === 0) {
                alert(`‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏µ‡∏ï ${sheetName}`);
                return;
            }
            
            workbookDataStore[sheetName].selectedHeaders = selectedHeaders;
            
            currentConfigSheetIndex++;

            if (currentConfigSheetIndex < sheetsToConfigure.length) {
                displaySheetForConfiguration();
            } else {
                finishHeaderConfiguration();
            }
        }

        function finishHeaderConfiguration() {
            headerConfigModal.hide();
            loadingSpinner.style.display = 'block';
            loadingStatusEl.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Dashboard...';

            Object.keys(workbookDataStore).forEach(sheetName => {
                const sheetInfo = workbookDataStore[sheetName];
                if (sheetInfo.selectedHeaders) {
                    const selected = sheetInfo.selectedHeaders;
                    
                    sheetInfo.data = sheetInfo.data.map(fullRow => {
                        const newRow = {};
                        selected.forEach(h => {
                            newRow[h] = fullRow[h];
                        });
                        return newRow;
                    });
                    
                    sheetInfo.headers = selected;
                }
            });

            setActiveSheet(Object.keys(workbookDataStore)[0]);
            loadingSpinner.style.display = 'none';
        }


        function setActiveSheet(sheetName) {
            if (!workbookDataStore[sheetName]) return;

            Object.values(chartInstances).forEach(chart => chart.destroy());
            chartInstances = {};
            activeFilters = [];
            userKPIs = [];
            userCharts = [];
            if (filterBuilderContainer) filterBuilderContainer.innerHTML = '';
            if (kpisContainer) kpisContainer.innerHTML = '';
            if (chartsContainer) chartsContainer.innerHTML = '';

            currentSheetName = sheetName;
            const sheetInfo = workbookDataStore[sheetName];
            
            fullOriginalData = sheetInfo.data;
            allHeaders = sheetInfo.headers; 
            
            headers = [...allHeaders];
            originalData = [...fullOriginalData];

            initializeDashboard();
        }
        
        function convertNumericColumns() {
            if (!numericHeaders || numericHeaders.length === 0) return;
            fullOriginalData.forEach(row => {
                numericHeaders.forEach(h => {
                    const val = row[h];
                    if (val !== null && val !== undefined && val !== '') {
                        const strVal = String(val).trim();
                        let cleanVal = strVal.replace(/[,\s‡∏ø$‚Ç¨¬£¬•"']/g, '').replace(/^\((.+)\)$/, '-$1').replace(/[^\d.-]/g, '');
                        let numVal = parseFloat(cleanVal);
                        
                        if (!isNaN(numVal) && isFinite(numVal)) {
                            row[h] = numVal;
                        } else {
                            row[h] = 0;
                        }
                    } else {
                        row[h] = 0;
                    }
                });
            });
            originalData = [...fullOriginalData];
        }

        /**
         * ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ null ‡∏´‡∏£‡∏∑‡∏≠ empty ‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏ñ‡∏ß ‡πÅ‡∏•‡∏∞‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥ (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß)
         */
        function removeEmptyRows() {
            try {
                const initialCount = fullOriginalData.length;
                console.log(`üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ${initialCount} ‡πÅ‡∏ñ‡∏ß`);
                console.log(`Headers ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô:`, headers);
                
                // Step 1: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç headers ‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
                const cleanedHeaders = fixDuplicateHeaders(headers);
                if (cleanedHeaders.length !== headers.length || cleanedHeaders.some((h, i) => h !== headers[i])) {
                    console.log(`üîß ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç headers ‡∏ã‡πâ‡∏≥:`, cleanedHeaders);
                    headers = cleanedHeaders;
                    allHeaders = [...headers];
                    
                    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö headers ‡πÉ‡∏´‡∏°‡πà
                    fullOriginalData = fullOriginalData.map(row => {
                        const newRow = {};
                        headers.forEach(header => {
                            newRow[header] = row[header] || null;
                        });
                        return newRow;
                    });
                }
                
                // Step 2: ‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
                const rowsWithData = fullOriginalData.filter(row => {
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    const significantValues = headers.filter(header => {
                        const value = row[header];
                        if (value === null || value === undefined) return false;
                        const strValue = String(value).trim();
                        if (strValue === '' || strValue.toLowerCase() === 'null' || strValue === '0') return false;
                        return strValue.length > 0;
                    });
                    
                    // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢
                    return significantValues.length > 0;
                });
                
                console.log(`üìä ‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ß‡πà‡∏≤‡∏á: ${rowsWithData.length} ‡πÅ‡∏ñ‡∏ß`);
                
                // Step 3: ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥
                const uniqueRowsMap = new Map();
                const deduplicatedData = [];
                
                rowsWithData.forEach((row, index) => {
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á signature ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡πÇ‡∏î‡∏¢‡∏î‡∏π‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢
                    const rowSignature = headers.map(header => {
                        const value = row[header];
                        if (value === null || value === undefined) return '';
                        return String(value).trim().toLowerCase();
                    }).join('|||');
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ signature ‡∏ô‡∏µ‡πâ‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    if (!uniqueRowsMap.has(rowSignature)) {
                        uniqueRowsMap.set(rowSignature, index);
                        deduplicatedData.push(row);
                    } else {
                        console.log(`üîç ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥‡∏ó‡∏µ‡πà‡πÅ‡∏ñ‡∏ß ${index + 1}`);
                    }
                });
                
                console.log(`‚úÖ ‡∏´‡∏•‡∏±‡∏á‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥: ${deduplicatedData.length} ‡πÅ‡∏ñ‡∏ß`);
                
                // Step 4: ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                fullOriginalData = deduplicatedData;
                originalData = [...fullOriginalData];
                
                const removedCount = initialCount - fullOriginalData.length;
                if (removedCount > 0) {
                    console.log(`üéØ ‡∏™‡∏£‡∏∏‡∏õ: ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏ã‡πâ‡∏≥ ${removedCount} ‡πÅ‡∏ñ‡∏ß ‡∏à‡∏≤‡∏Å ${initialCount} ‡πÅ‡∏ñ‡∏ß (‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${fullOriginalData.length} ‡πÅ‡∏ñ‡∏ß)`);
                }
                
                // Step 5: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                if (fullOriginalData.length === 0) {
                    console.warn('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á!');
                    alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
                }
                
            } catch (error) {
                console.error('‚ùå Error in removeEmptyRows:', error);
                alert(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ${error.message}`);
            }
        }
        
        /**
         * ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç headers ‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç
         */
        function fixDuplicateHeaders(originalHeaders) {
            const headerCounts = {};
            const fixedHeaders = [];
            
            originalHeaders.forEach(header => {
                const cleanHeader = String(header || '').trim();
                if (!cleanHeader) {
                    fixedHeaders.push(`Column_${fixedHeaders.length + 1}`);
                    return;
                }
                
                // ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥
                headerCounts[cleanHeader] = (headerCounts[cleanHeader] || 0) + 1;
                
                // ‡∏ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥ ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç
                if (headerCounts[cleanHeader] > 1) {
                    fixedHeaders.push(`${cleanHeader}_${headerCounts[cleanHeader]}`);
                } else {
                    fixedHeaders.push(cleanHeader);
                }
            });
            
            return fixedHeaders;
        }

        function detectNumericHeaders() {
            numericHeaders = allHeaders.filter(h => {
                const nonEmptyValues = fullOriginalData.map(row => row[h]).filter(val => val !== null && val !== undefined && String(val).trim() !== '');
                if (nonEmptyValues.length < 5) return false;
                
                const numericCount = nonEmptyValues.filter(val => {
                    const strVal = String(val).trim();
                    const cleanVal = strVal.replace(/[,\s‡∏ø$‚Ç¨¬£¬•]/g, '').replace(/^\((.+)\)$/, '-$1');
                    return !isNaN(parseFloat(cleanVal)) && isFinite(cleanVal);
                }).length;
                
                return (numericCount / nonEmptyValues.length) >= 0.7;
            });
        }
        
        /**
         * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Excel ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
         */
        function debugExcelData() {
            console.log('=== üîç EXCEL DATA DEBUG ===');
            console.log('üìÑ Current fileName:', currentFileName);
            console.log('üìä Current sheet:', currentSheetName);
            
            if (workbookDataStore && Object.keys(workbookDataStore).length > 0) {
                console.log('üìö Available sheets:', Object.keys(workbookDataStore));
                
                Object.keys(workbookDataStore).forEach(sheetName => {
                    const sheetInfo = workbookDataStore[sheetName];
                    console.log(`\n--- Sheet: ${sheetName} ---`);
                    console.log('üìã Original headers:', sheetInfo.headers);
                    console.log('üî¢ Header count:', sheetInfo.headers?.length || 0);
                    console.log('üìà Data rows:', sheetInfo.data?.length || 0);
                    
                    if (sheetInfo.data && sheetInfo.data.length > 0) {
                        console.log('üìù First row sample:', sheetInfo.data[0]);
                        console.log('üóÇÔ∏è All keys in first row:', Object.keys(sheetInfo.data[0]));
                    }
                });
            }
            
            if (fullOriginalData && fullOriginalData.length > 0) {
                console.log('\n--- Current Active Data ---');
                console.log('üìã Active headers:', headers);
                console.log('üî¢ Active header count:', headers.length);
                console.log('üìà Active data rows:', fullOriginalData.length);
                console.log('üìù First active row:', fullOriginalData[0]);
                console.log('üóÇÔ∏è Keys in first active row:', Object.keys(fullOriginalData[0]));
            }
            
            console.log('============================');
        }
        
        /**
         * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
         */
        function debugDataInfo() {
            console.log('=== üîç DEBUG DATA INFO ===');
            console.log('üìã Headers:', headers);
            console.log('üìä Headers length:', headers.length);
            console.log('üî¢ Numeric headers:', numericHeaders);
            console.log('üìà Total rows:', fullOriginalData.length);
            
            if (fullOriginalData.length > 0) {
                console.log('üìù Data sample (first 3 rows):');
                fullOriginalData.slice(0, 3).forEach((row, index) => {
                    console.log(`Row ${index + 1}:`, row);
                });
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö headers ‡∏ã‡πâ‡∏≥
                const headerCounts = {};
                headers.forEach(header => {
                    headerCounts[header] = (headerCounts[header] || 0) + 1;
                });
                const duplicates = Object.entries(headerCounts).filter(([_, count]) => count > 1);
                if (duplicates.length > 0) {
                    console.warn('‚ö†Ô∏è Headers ‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥:', duplicates);
                }
            }
            console.log('========================');
        }
        
        function generateDashboardTemplates(sheetName) {
            const sheetInfo = workbookDataStore[sheetName];
            const currentAllHeaders = sheetInfo.headers;
            const currentNumericHeaders = currentAllHeaders.filter(h => {
                 const nonEmptyValues = sheetInfo.data.map(row => row[h]).filter(val => val !== null && val !== undefined && String(val).trim() !== '');
                if (nonEmptyValues.length < 5) return false;
                const numericCount = nonEmptyValues.filter(val => {
                    const strVal = String(val).trim();
                    const cleanVal = strVal.replace(/[,\s‡∏ø$‚Ç¨¬£¬•]/g, '').replace(/^\((.+)\)$/, '-$1');
                    return !isNaN(parseFloat(cleanVal)) && isFinite(cleanVal);
                }).length;
                return (numericCount / nonEmptyValues.length) >= 0.7;
            });

            const templates = [];
            
            if (currentAllHeaders.includes('department') && currentAllHeaders.includes('hotel') && currentAllHeaders.includes('value')) {
                 const config = {
                    headers: ['department', 'hotel', 'type', 'period', 'value'],
                    userKPIs: [
                        { id: `kpi-hr-1`, title: `‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î`, calculation: 'sum', column: 'value' },
                        { id: `kpi-hr-2`, title: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ú‡∏ô‡∏Å`, calculation: 'uniqueCount', column: 'department' },
                        { id: `kpi-hr-3`, title: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°`, calculation: 'uniqueCount', column: 'hotel' }
                    ],
                    userCharts: [
                        { id: 'chart-hr-1', title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡∏Å', type: 'bar', groupBy: 'department', metric: 'value', aggregation: 'sum' },
                        { id: 'chart-hr-2', title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°', type: 'pie', groupBy: 'hotel', metric: 'value', aggregation: 'sum' }
                    ]
                };
                templates.push({ name: "‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô (HR Staffing)", description: "‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡∏Å‡πÅ‡∏•‡∏∞‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°", config });
            }

            if (currentNumericHeaders.length > 0 && currentAllHeaders.length > currentNumericHeaders.length) {
                const firstCategoryCol = currentAllHeaders.find(h => !currentNumericHeaders.includes(h));
                const firstNumericCol = currentNumericHeaders[0];
                if (firstCategoryCol && firstNumericCol) {
                    const config = {
                         headers: currentAllHeaders,
                         userKPIs: [
                            { id: 'kpi-gen-1', title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î', calculation: 'count', column: null },
                            { id: 'kpi-gen-2', title: `‡∏ú‡∏•‡∏£‡∏ß‡∏° ${firstNumericCol}`, calculation: 'sum', column: firstNumericCol },
                         ],
                         userCharts: [{ id: 'chart-gen-1', title: `‡∏ú‡∏•‡∏£‡∏ß‡∏° ${firstNumericCol} ‡∏ï‡∏≤‡∏° ${firstCategoryCol}`, type: 'bar', groupBy: firstCategoryCol, metric: firstNumericCol, aggregation: 'sum' }]
                    };
                    templates.push({ name: "‡∏™‡∏≥‡∏£‡∏ß‡∏à‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô (General Exploration)", description: `‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡∏∞‡∏î‡∏π‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á ${firstNumericCol} ‡∏ï‡∏≤‡∏° ${firstCategoryCol}`, config });
                }
            }

            return templates;
        }

        function generateAndShowTemplates() {
            try {
                if (!workbookDataStore || typeof workbookDataStore !== 'object' || Object.keys(workbookDataStore).length === 0) {
                    throw new Error("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• workbook ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á template");
                }

                const firstSheetName = Object.keys(workbookDataStore)[0];
                if (!firstSheetName) {
                    throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö sheet name ‡πÉ‡∏ô workbook data");
                }

                const templates = generateDashboardTemplates(firstSheetName);
                const container = getEl('template-card-container');
                
                if (!container) {
                    throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö template container element");
                }
                
                container.innerHTML = '';

                if (!templates || !Array.isArray(templates) || templates.length === 0) {
                    console.warn("‡πÑ‡∏°‡πà‡∏û‡∏ö templates ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° - ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£ header configuration");
                    startHeaderConfigurationFlow(Object.keys(workbookDataStore));
                    return;
                }

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á template cards
                templates.forEach((template, index) => {
                    try {
                        if (!template || typeof template !== 'object') {
                            console.warn(`Template at index ${index} is invalid:`, template);
                            return;
                        }

                        const cardWrapper = document.createElement('div');
                        cardWrapper.className = 'col-md-6';
                        
                        const card = document.createElement('div');
                        card.className = 'card h-100 template-card border';
                        card.onclick = () => applyTemplateAndInitialize(template.config, firstSheetName);
                        
                        const firstChartConfig = template.config?.userCharts?.[0];
                        const previewCanvasId = firstChartConfig ? `preview-${firstChartConfig.id}` : `preview-empty-${index}`;

                        card.innerHTML = `
                            <div class="chart-preview-container bg-light p-2 rounded-top">
                                <canvas id="${previewCanvasId}"></canvas>
                            </div>
                            <div class="card-body">
                                <h5 class="card-title text-primary">${template.name || 'Unnamed Template'}</h5>
                                <p class="card-text text-muted small">${template.description || 'No description available'}</p>
                            </div>
                        `;
                        cardWrapper.appendChild(card);
                        container.appendChild(cardWrapper);
                    } catch (error) {
                        console.error(`Error creating template card ${index}:`, error);
                    }
                });
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á preview charts
                templates.forEach((template, index) => {
                    try {
                        const firstChartConfig = template.config?.userCharts?.[0];
                        if (firstChartConfig) {
                            const previewCanvasId = `preview-${firstChartConfig.id}`;
                            renderPreviewChart(firstChartConfig, previewCanvasId, firstSheetName);
                        }
                    } catch (error) {
                        console.error(`Error rendering preview chart for template ${index}:`, error);
                    }
                });

                loadingSpinner.style.display = 'none';
                
                if (!templateSelectModal) {
                    throw new Error("templateSelectModal ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å initialized");
                }
                
                templateSelectModal.show();
                
            } catch (error) {
                console.error('Error in generateAndShowTemplates:', error);
                loadingSpinner.style.display = 'none';
                uploadErrorEl.textContent = `‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á template: ${error.message}`;
                throw error;
            }
        }

        function renderPreviewChart(config, canvasId, sheetName) {
            try {
                if (!config || typeof config !== 'object') {
                    throw new Error("Chart config ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
                }

                if (!canvasId || typeof canvasId !== 'string') {
                    throw new Error("Canvas ID ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
                }

                if (!sheetName || !workbookDataStore[sheetName]) {
                    throw new Error(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö sheet: ${sheetName}`);
                }

                const data = workbookDataStore[sheetName].data;
                if (!data || !Array.isArray(data) || data.length === 0) {
                    console.warn(`‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö preview chart ‡πÉ‡∏ô sheet: ${sheetName}`);
                    return;
                }

                if (!config.groupBy) {
                    console.warn("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ groupBy ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö chart");
                    return;
                }

                let chartData;
                const aggregation = config.aggregation || 'sum';
                const metric = config.metric;

                try {
                    if (aggregation === 'count' || aggregation === 'uniqueCount') {
                        const counts = data.reduce((acc, row) => {
                            try {
                                const key = row[config.groupBy] || 'N/A';
                                if (!acc[key]) acc[key] = new Set();
                                if (aggregation === 'uniqueCount') acc[key].add(row[metric]);
                                else acc[key].add(row[config.groupBy]);
                                return acc;
                            } catch (error) {
                                console.warn('Error processing row for count aggregation:', error);
                                return acc;
                            }
                        }, {});
                        chartData = { 
                            labels: Object.keys(counts), 
                            values: Object.values(counts).map(s => s.size) 
                        };
                    } else { 
                        const metrics = data.reduce((acc, row) => {
                            try {
                                const key = row[config.groupBy] || 'N/A';
                                if (!acc[key]) acc[key] = { sum: 0, count: 0 };
                                const value = parseFloat(row[metric] || 0);
                                if (!isNaN(value) && isFinite(value)) {
                                    acc[key].sum += value;
                                    acc[key].count += 1;
                                }
                                return acc;
                            } catch (error) {
                                console.warn('Error processing row for numeric aggregation:', error);
                                return acc;
                            }
                        }, {});
                        
                        chartData = {
                            labels: Object.keys(metrics),
                            values: Object.values(metrics).map(m => {
                                if (m.count === 0) return 0;
                                return aggregation === 'sum' ? m.sum : (m.sum / m.count);
                            })
                        };
                    }
                } catch (error) {
                    throw new Error(`Error aggregating data: ${error.message}`);
                }

                if (!chartData.labels || chartData.labels.length === 0) {
                    console.warn("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö chart ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å aggregation");
                    return;
                }

                // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö preview
                const maxPreviewPoints = 10;
                if (chartData.labels.length > maxPreviewPoints) {
                    try {
                        const combined = chartData.labels.map((label, i) => ({ 
                            label, 
                            value: chartData.values[i] || 0 
                        }));
                        combined.sort((a, b) => b.value - a.value);
                        chartData.labels = combined.slice(0, maxPreviewPoints).map(d => d.label);
                        chartData.values = combined.slice(0, maxPreviewPoints).map(d => d.value);
                    } catch (error) {
                        console.warn('Error limiting preview data points:', error);
                    }
                }

                const canvas = getEl(canvasId);
                if (!canvas) {
                    console.warn(`‡πÑ‡∏°‡πà‡∏û‡∏ö canvas element: ${canvasId}`);
                    return;
                }

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.warn(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á 2d context ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö canvas: ${canvasId}`);
                    return;
                }

                // ‡∏ó‡∏≥‡∏•‡∏≤‡∏¢ chart instance ‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                if (chartInstances[canvasId]) {
                    try {
                        chartInstances[canvasId].destroy();
                    } catch (error) {
                        console.warn('Error destroying existing chart:', error);
                    }
                }

                chartInstances[canvasId] = new Chart(ctx, {
                    type: config.type || 'bar',
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            data: chartData.values,
                            backgroundColor: config.type === 'line' ? 'rgba(0, 123, 255, 0.1)' : ['#0d6efd', '#6c757d', '#198754', '#ffc107', '#dc3545', '#0dcaf0', '#fd7e14'],
                            borderColor: '#0d6efd',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: config.type === 'line'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false }, 
                            tooltip: { enabled: false }, 
                            datalabels: { display: false } 
                        },
                        scales: { 
                            x: { display: false }, 
                            y: { display: false } 
                        }
                    }
                });

            } catch (error) {
                console.error(`Error in renderPreviewChart for canvas ${canvasId}:`, error);
            }
        }

        function applyTemplateAndInitialize(config, sheetName) {
            templateSelectModal.hide();
            loadingSpinner.style.display = 'block';

            const firstSheetInfo = workbookDataStore[sheetName];
            firstSheetInfo.selectedHeaders = [...new Set(config.headers)];
            firstSheetInfo.data = firstSheetInfo.data.map(fullRow => {
                const newRow = {};
                firstSheetInfo.selectedHeaders.forEach(h => { newRow[h] = fullRow[h]; });
                return newRow;
            });
            firstSheetInfo.headers = firstSheetInfo.selectedHeaders;

            Object.keys(workbookDataStore).forEach(sName => {
                if (sName !== sheetName) {
                    const otherSheetInfo = workbookDataStore[sName];
                    otherSheetInfo.selectedHeaders = otherSheetInfo.headers;
                }
            });

            setActiveSheet(sheetName);
            
            userKPIs = config.userKPIs || [];
            userCharts = config.userCharts || [];
            activeFilters = config.activeFilters || [];
            
            applyFiltersAndRender();
            
            loadingSpinner.style.display = 'none';
        }

        function renderSheetSwitcher() {
            const container = getEl('sheet-switcher-container');
            container.innerHTML = '';
            const sheetNames = Object.keys(workbookDataStore);

            if (sheetNames.length > 1) {
                const switcherGroup = document.createElement('div');
                switcherGroup.className = 'btn-group btn-group-sm mt-2';
                switcherGroup.setAttribute('role', 'group');
                
                sheetNames.forEach(name => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = `btn ${name === currentSheetName ? 'btn-primary' : 'btn-outline-primary'}`;
                    button.textContent = name;
                    button.onclick = () => {
                        if (name !== currentSheetName) {
                            setActiveSheet(name);
                        }
                    };
                    switcherGroup.appendChild(button);
                });
                container.appendChild(switcherGroup);
            }
        }

        function initializeDashboard() {
            fileInfoEl.textContent = `‡πÑ‡∏ü‡∏•‡πå: ${currentFileName}`;
            uploadView.classList.add('d-none');
            dashboardView.classList.remove('d-none');
            
            renderSheetSwitcher();
            
            console.log('üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...');
            
            // Debug ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Excel ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
            console.log('üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Excel ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö:');
            debugExcelData();
            
            // Debug ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î
            console.log('üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î:');
            debugDataInfo();
            
            detectNumericHeaders();
            removeEmptyRows(); // ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ß‡πà‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            convertNumericColumns();
            
            // Debug ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î
            console.log('üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î:');
            debugDataInfo();

            sortKey = headers.length > 0 ? headers[0] : '';
            renderTableHeader();

            const savedConfig = loadStateFromLocalStorage();
            
            const headersMatch = savedConfig && savedConfig.headers && savedConfig.headers.every(h => headers.includes(h)) && savedConfig.headers.length === headers.length;

            if (headersMatch) {
                applyConfiguration(savedConfig);
            } else {
                applyFiltersAndRender();
            }
            
            console.log('‚úÖ Dashboard initialization ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô');
        }

        function renderTableHeader() {
            tableHeaderEl.innerHTML = '';
            const tr = document.createElement('tr');
            tr.className = 'main-header-row';
            
            headers.forEach((header, colIndex) => {
                const th = document.createElement('th');
                th.className = 'p-1 sortable-header';
                th.dataset.sortKey = header;
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á wrapper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö header text ‡πÅ‡∏•‡∏∞ sort indicator
                const headerWrapper = document.createElement('div');
                headerWrapper.className = 'd-flex align-items-center justify-content-center position-relative';
                
                const headerText = document.createElement('span');
                headerText.textContent = header;
                headerText.className = 'me-1';
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° icon ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
                const isMonthCol = isMonthColumnType(header);
                if (isMonthCol) {
                    const monthIcon = document.createElement('i');
                    monthIcon.className = 'bi bi-calendar3 me-1 text-info';
                    monthIcon.title = '‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏î‡∏∑‡∏≠‡∏ô - ‡∏à‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô';
                    headerWrapper.appendChild(monthIcon);
                }
                
                headerWrapper.appendChild(headerText);
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° sort icon
                const sortIcon = document.createElement('i');
                sortIcon.className = 'bi bi-arrow-down-up sort-icon ms-1';
                sortIcon.style.fontSize = '12px';
                sortIcon.style.opacity = '0.5';
                headerWrapper.appendChild(sortIcon);
                
                th.appendChild(headerWrapper);
                
                // ‡πÉ‡∏ä‡πâ styling ‡πÅ‡∏ö‡∏ö Excel ‡πÄ‡∏™‡∏°‡∏≠
                th.style.cssText = `
                    cursor: pointer; 
                    position: relative; 
                    background-color: #f6f8fa; 
                    font-weight: 600; 
                    border: 1px solid #d0d7de;
                    text-align: center;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    font-size: 13px;
                    min-width: 120px;
                `;
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° hover effect
                th.addEventListener('mouseenter', () => {
                    th.style.backgroundColor = '#e9ecef';
                    sortIcon.style.opacity = '1';
                });
                th.addEventListener('mouseleave', () => {
                    th.style.backgroundColor = '#f6f8fa';
                    if (sortKey !== header) {
                        sortIcon.style.opacity = '0.5';
                    }
                });
                
                tr.appendChild(th);
            });
            
            tableHeaderEl.appendChild(tr);
            updateSortIndicators();
        }
        
        function renderTableTotalRow() {
            const existingTotalRow = tableHeaderEl.querySelector('.total-row');
            if (existingTotalRow) existingTotalRow.remove();
            if (filteredData.length === 0) return;

            const totalRow = document.createElement('tr');
            totalRow.className = 'table-light total-row fw-bold';

            let hasPlacedTotalLabel = false;
            headers.forEach(header => {
                const th = document.createElement('th');
                th.className = 'p-3';
                if (numericHeaders.includes(header)) {
                    const total = filteredData.reduce((sum, row) => sum + (row[header] || 0), 0);
                    th.textContent = total.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                    th.classList.add('text-end');
                } else {
                    if (!hasPlacedTotalLabel) {
                        th.textContent = 'Total';
                        hasPlacedTotalLabel = true;
                    } else {
                        th.textContent = '';
                    }
                }
                totalRow.appendChild(th);
            });
            tableHeaderEl.prepend(totalRow);
        }


        function renderTableBody() {
            tableBodyEl.innerHTML = '';
            noResultsEl.classList.toggle('d-none', filteredData.length > 0);
            if (filteredData.length === 0) return;

            const totalPages = Math.ceil(filteredData.length / rowsPerPage);
            currentPage = Math.min(currentPage, totalPages) || 1;
            const start = (currentPage - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            const paginatedItems = filteredData.slice(start, end);

            // ‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö Excel ‡πÄ‡∏™‡∏°‡∏≠ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¥‡∏á‡∏à‡∏≤‡∏Å Excel data ‡∏à‡∏£‡∏¥‡∏á)
            paginatedItems.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                
                headers.forEach((header, colIndex) => {
                    const td = document.createElement('td');
                    td.className = 'p-1';
                    const value = row[header];
                    
                    // ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                    if (typeof value === 'number' && numericHeaders.includes(header)) {
                        td.textContent = value.toLocaleString('th-TH');
                        td.classList.add('text-end', 'excel-number');
                        td.style.fontFamily = 'Consolas, Monaco, "Lucida Console", monospace';
                    } else if (value instanceof Date) {
                        td.textContent = value.toLocaleDateString('th-TH');
                        td.classList.add('text-center', 'excel-date');
                    } else {
                        td.textContent = String(value === undefined || value === null ? '' : value);
                        td.classList.add('excel-text');
                    }
                    
                    // ‡πÄ‡∏û‡∏¥‡πà‡∏° hover effect
                    td.addEventListener('mouseenter', () => {
                        td.style.backgroundColor = '#f1f8ff';
                    });
                    td.addEventListener('mouseleave', () => {
                        td.style.backgroundColor = '';
                    });
                    
                    tr.appendChild(td);
                });
                tableBodyEl.appendChild(tr);
            });
            
            renderPaginationControls(filteredData.length, totalPages);
        }

        function renderPaginationControls(totalItems, totalPages) {
            paginationControls.innerHTML = '';
            if (totalItems === 0) return;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'd-flex align-items-center gap-3';
            const startItem = (currentPage - 1) * rowsPerPage + 1;
            const endItem = Math.min(startItem + rowsPerPage - 1, totalItems);
            
            const pageInfo = document.createElement('span');
            pageInfo.className = 'text-muted text-nowrap';
            pageInfo.textContent = `‡πÅ‡∏™‡∏î‡∏á ${startItem} - ${endItem} ‡∏à‡∏≤‡∏Å ${totalItems}`;

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'btn-group';
            const prevButton = document.createElement('button');
            prevButton.innerHTML = '&laquo;';
            prevButton.className = 'btn btn-outline-secondary btn-sm';
            prevButton.disabled = currentPage === 1;
            prevButton.onclick = () => { if (currentPage > 1) { currentPage--; renderTableBody(); } };
            const nextButton = document.createElement('button');
            nextButton.innerHTML = '&raquo;';
            nextButton.className = 'btn btn-outline-secondary btn-sm';
            nextButton.disabled = currentPage === totalPages;
            nextButton.onclick = () => { if (currentPage < totalPages) { currentPage++; renderTableBody(); } };

            buttonsContainer.append(prevButton, nextButton);
            wrapper.append(pageInfo, buttonsContainer);
            paginationControls.append(wrapper);
        }

        function applyFiltersAndRender() {
            let data = [...originalData];
            activeFilters.forEach(filter => {
                if (filter.column && filter.value) {
                    const filterValue = String(filter.value).toLowerCase();
                    data = data.filter(row => String(row[filter.column] || '').toLowerCase().includes(filterValue));
                }
            });

            filteredData = data;
            currentPage = 1;
            sortData();
            renderTableBody();
            renderTableTotalRow();
            renderAllKpis();
            renderAllCharts();
        }

        function addFilterRow(filterConfig = null) {
            const filterId = filterConfig ? filterConfig.id : `filter-${Date.now()}`;
            const filterRow = document.createElement('div');
            filterRow.id = filterId;
            filterRow.className = 'row g-2 align-items-center mb-2 p-2 filter-row';
            const headerOptions = headers.map(h => `<option value="${h}" ${filterConfig && filterConfig.column === h ? 'selected' : ''}>${h}</option>`).join('');
            filterRow.innerHTML = `
                <div class="col-md-5"><select class="form-select form-select-sm" data-role="column"><option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå --</option>${headerOptions}</select></div>
                <div class="col-md-6"><input type="text" class="form-control form-control-sm" placeholder="‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤..." data-role="value" value="${filterConfig ? (filterConfig.value || '') : ''}"></div>
                <div class="col-md-1"><button class="btn btn-sm btn-outline-danger" data-role="remove"><i class="bi bi-trash"></i></button></div>`;
            filterBuilderContainer.appendChild(filterRow);
            
            const currentFilter = activeFilters.find(f => f.id === filterId);
            const newFilter = currentFilter || { id: filterId, column: filterConfig?.column || '', value: filterConfig?.value || '' };
            if (!currentFilter) activeFilters.push(newFilter);

            filterRow.querySelector('[data-role="column"]').addEventListener('change', (e) => { newFilter.column = e.target.value; saveStateToLocalStorage(); applyFiltersAndRender(); });
            filterRow.querySelector('[data-role="value"]').addEventListener('input', (e) => { newFilter.value = e.target.value; saveStateToLocalStorage(); applyFiltersAndRender(); });
            filterRow.querySelector('[data-role="remove"]').addEventListener('click', () => { activeFilters = activeFilters.filter(f => f.id !== filterId); filterRow.remove(); saveStateToLocalStorage(); applyFiltersAndRender(); });
        }

        function sortData() {
            if (!sortKey) return;
            const isNumeric = numericHeaders.includes(sortKey);
            const isMonthColumn = isMonthColumnType(sortKey);
            
            filteredData.sort((a, b) => {
                let valA = a[sortKey];
                let valB = b[sortKey];
                
                // Handle null/undefined values
                if (valA === null || valA === undefined) valA = '';
                if (valB === null || valB === undefined) valB = '';
                
                // Handle month sorting
                if (isMonthColumn) {
                    const monthOrderA = getMonthOrder(valA);
                    const monthOrderB = getMonthOrder(valB);
                    
                    // If both are valid months, sort by month order
                    if (monthOrderA !== -1 && monthOrderB !== -1) {
                        if (monthOrderA < monthOrderB) return sortDir === 'asc' ? -1 : 1;
                        if (monthOrderA > monthOrderB) return sortDir === 'asc' ? 1 : -1;
                        return 0;
                    }
                    // If only one is a valid month, put valid months first
                    if (monthOrderA !== -1 && monthOrderB === -1) return sortDir === 'asc' ? -1 : 1;
                    if (monthOrderA === -1 && monthOrderB !== -1) return sortDir === 'asc' ? 1 : -1;
                    // If neither is a valid month, fall through to normal sorting
                }
                
                // Handle numeric sorting
                if (isNumeric) { 
                    valA = valA || 0; 
                    valB = valB || 0; 
                } else { 
                    valA = String(valA).toLowerCase(); 
                    valB = String(valB).toLowerCase(); 
                }
                
                if (valA < valB) return sortDir === 'asc' ? -1 : 1;
                if (valA > valB) return sortDir === 'asc' ? 1 : -1;
                return 0;
            });
            updateSortIndicators();
        }
        
        /**
         * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
         */
        function isMonthColumnType(columnName) {
            if (!columnName) return false;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
            const monthColumnNames = ['period', 'month', '‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', '‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤'];
            if (monthColumnNames.some(name => columnName.toLowerCase().includes(name.toLowerCase()))) {
                return true;
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            const sampleValues = filteredData.slice(0, 10).map(row => row[columnName]).filter(val => val);
            if (sampleValues.length === 0) return false;
            
            const monthLikeCount = sampleValues.filter(val => getMonthOrder(val) !== -1).length;
            return (monthLikeCount / sampleValues.length) >= 0.7; // ‡∏ñ‡πâ‡∏≤ 70% ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
        }
        
        /**
         * ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç (0-11 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Jan-Dec, 12 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Avg/Total)
         */
        function getMonthOrder(value) {
            if (!value) return -1;
            
            const strValue = String(value).trim().toLowerCase();
            
            // ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö "mmm-yyyy" ‡πÄ‡∏ä‡πà‡∏ô "jan-2024"
            const monthYearMatch = strValue.match(/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(\d{4})$/);
            if (monthYearMatch) {
                const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
                const monthIndex = monthNames.indexOf(monthYearMatch[1]);
                const year = parseInt(monthYearMatch[2]);
                // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏õ‡∏µ‡πÅ‡∏•‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏õ‡∏µ
                return year * 12 + monthIndex;
            }
            
            // ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
            const monthNames = {
                'jan': 0, 'january': 0, '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°': 0, '‡∏°.‡∏Ñ.': 0,
                'feb': 1, 'february': 1, '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå': 1, '‡∏Å.‡∏û.': 1,
                'mar': 2, 'march': 2, '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°': 2, '‡∏°‡∏µ.‡∏Ñ.': 2,
                'apr': 3, 'april': 3, '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô': 3, '‡πÄ‡∏°.‡∏¢.': 3,
                'may': 4, '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°': 4, '‡∏û.‡∏Ñ.': 4,
                'jun': 5, 'june': 5, '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô': 5, '‡∏°‡∏¥.‡∏¢.': 5,
                'jul': 6, 'july': 6, '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°': 6, '‡∏Å.‡∏Ñ.': 6,
                'aug': 7, 'august': 7, '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°': 7, '‡∏™.‡∏Ñ.': 7,
                'sep': 8, 'september': 8, '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô': 8, '‡∏Å.‡∏¢.': 8,
                'oct': 9, 'october': 9, '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°': 9, '‡∏ï.‡∏Ñ.': 9,
                'nov': 10, 'november': 10, '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô': 10, '‡∏û.‡∏¢.': 10,
                'dec': 11, 'december': 11, '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°': 11, '‡∏ò.‡∏Ñ.': 11,
                'avg': 12, 'average': 12, 'total': 12, '‡∏£‡∏ß‡∏°': 12, '‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢': 12
            };
            
            for (const [key, order] of Object.entries(monthNames)) {
                if (strValue.includes(key)) {
                    return order;
                }
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÄ‡∏î‡∏∑‡∏≠‡∏ô (1-12)
            const numMatch = strValue.match(/^(\d{1,2})$/);
            if (numMatch) {
                const num = parseInt(numMatch[1]);
                if (num >= 1 && num <= 12) {
                    return num - 1; // ‡πÅ‡∏õ‡∏•‡∏á 1-12 ‡πÄ‡∏õ‡πá‡∏ô 0-11
                }
            }
            
            return -1; // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
        }

        function updateSortIndicators() {
            tableHeaderEl.querySelectorAll('th').forEach(th => {
                const sortIcon = th.querySelector('.sort-icon');
                if (!sortIcon) return;
                
                // Reset all icons
                sortIcon.className = 'bi bi-arrow-down-up sort-icon ms-1';
                sortIcon.style.opacity = '0.5';
                
                // Update active sort column
                if (th.dataset.sortKey === sortKey) {
                    sortIcon.style.opacity = '1';
                    if (sortDir === 'asc') {
                        sortIcon.className = 'bi bi-arrow-up sort-icon ms-1 text-primary';
                    } else {
                        sortIcon.className = 'bi bi-arrow-down sort-icon ms-1 text-primary';
                    }
                }
            });
        }

        function openCreateKpiModal() {
            getEl('create-kpi-form').reset();
            const calcSelect = getEl('kpi-calculation');
            const colSelect = getEl('kpi-column');
            const colContainer = getEl('kpi-column-container');
            
            calcSelect.innerHTML = `<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å --</option><option value="sum">‡∏ú‡∏•‡∏£‡∏ß‡∏° (Sum)</option><option value="average">‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (Average)</option><option value="uniqueCount">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏ö (‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥)</option><option value="count">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏ö (‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)</option>`; 
            
            calcSelect.onchange = () => {
                const selection = calcSelect.value;
                let colOptions = '';
                if (selection === 'sum' || selection === 'average') { colOptions = numericHeaders.map(h => `<option value="${h}">${h}</option>`).join(''); colContainer.style.display = 'block'; } 
                else if (selection === 'uniqueCount') { colOptions = headers.map(h => `<option value="${h}">${h}</option>`).join(''); colContainer.style.display = 'block'; } 
                else { colContainer.style.display = 'none'; }
                colSelect.innerHTML = colOptions;
            };
            calcSelect.onchange();
            kpiModal.show();
        }

        function saveKpi() {
            const form = getEl('create-kpi-form');
            if (!form.checkValidity()) { form.classList.add('was-validated'); return; }
            const calculation = getEl('kpi-calculation').value;
            userKPIs.push({
                id: `kpi-${Date.now()}`,
                title: getEl('kpi-title').value,
                calculation: calculation,
                column: calculation !== 'count' ? getEl('kpi-column').value : null
            });
            kpiModal.hide();
            saveStateToLocalStorage();
            renderAllKpis();
        }

        function renderAllKpis() {
            kpisContainer.innerHTML = '';
            if (userKPIs.length === 0) { kpisContainer.appendChild(noKpisPlaceholder); noKpisPlaceholder.style.display = 'block'; return; }
            noKpisPlaceholder.style.display = 'none';

            userKPIs.forEach(config => {
                let value = 0;
                const data = filteredData;
                switch(config.calculation) {
                    case 'sum': value = data.reduce((sum, row) => sum + (row[config.column] || 0), 0); break;
                    case 'average': const sum = data.reduce((s, row) => s + (row[config.column] || 0), 0); value = data.length > 0 ? sum / data.length : 0; break;
                    case 'uniqueCount': value = new Set(data.map(row => row[config.column])).size; break;
                    case 'count': value = data.length; break;
                }
                const kpiWrapper = document.createElement('div');
                kpiWrapper.className = 'col-md-4 col-sm-6 mb-4 kpi-card';
                let formattedValue = (config.calculation === 'sum' || config.calculation === 'average') ? value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : value.toLocaleString();
                kpiWrapper.innerHTML = `<div class="card position-relative"><div class="card-body text-center p-4"><h2 class="text-muted fs-6 mb-2">${config.title}</h2><p class="h2 fw-bold text-primary mb-0">${formattedValue}</p></div><button class="btn btn-sm btn-danger position-absolute top-0 end-0 m-2" style="line-height:1" data-kpi-id="${config.id}" title="‡∏•‡∏ö KPI">&times;</button></div>`;
                kpisContainer.appendChild(kpiWrapper);
            });
            kpisContainer.querySelectorAll('[data-kpi-id]').forEach(btn => btn.addEventListener('click', (e) => { userKPIs = userKPIs.filter(k => k.id !== e.currentTarget.dataset.kpiId); saveStateToLocalStorage(); renderAllKpis(); }));
        }

        function openCreateChartModal() {
            getEl('create-chart-form').reset();
            const groupBySelect = getEl('chart-group-by');
            const metricSelect = getEl('chart-metric');
            const aggregationContainer = getEl('metric-aggregation-container');
            const allHeaderOptions = headers.map(h => `<option value="${h}">${h}</option>`).join('');
            const numericHeaderOptions = numericHeaders.map(h => `<option value="${h}">${h}</option>`).join('');
            groupBySelect.innerHTML = `<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå --</option>${allHeaderOptions}`;
            metricSelect.innerHTML = `<option value="count">‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß (Count)</option>${numericHeaderOptions}`;
            metricSelect.onchange = function() { aggregationContainer.style.display = this.value === 'count' ? 'none' : 'block'; };
            metricSelect.onchange();
            createChartModal.show();
        }

        function saveChart() {
            const form = getEl('create-chart-form');
            if (!form.checkValidity()) { form.classList.add('was-validated'); return; }
            userCharts.push({
                id: `chart-${Date.now()}`, title: getEl('chart-title').value, type: getEl('chart-type').value,
                groupBy: getEl('chart-group-by').value, metric: getEl('chart-metric').value, aggregation: getEl('chart-metric-aggregation').value
            });
            createChartModal.hide();
            saveStateToLocalStorage();
            renderAllCharts();
        }

        function renderAllCharts() {
            chartsContainer.innerHTML = '';
            if (userCharts.length === 0) { chartsContainer.appendChild(noChartsPlaceholder); noChartsPlaceholder.style.display = 'block'; return; }
            noChartsPlaceholder.style.display = 'none';

            userCharts.forEach(config => {
                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'col-lg-6 mb-4';
                chartWrapper.innerHTML = `<div class="card"><div class="card-header d-flex justify-content-between align-items-center"><span>${config.title}</span><button class="btn btn-sm btn-outline-light rounded-circle" data-chart-id="${config.id}" title="‡∏•‡∏ö‡∏Å‡∏£‡∏≤‡∏ü"><i class="bi bi-x-lg"></i></button></div><div class="card-body"><div class="chart-container" style="height: 400px;"><canvas id="${config.id}"></canvas></div></div></div>`;
                chartsContainer.appendChild(chartWrapper);
                renderChart(config);
            });
            chartsContainer.querySelectorAll('[data-chart-id]').forEach(btn => btn.addEventListener('click', (e) => {
                const chartId = e.currentTarget.dataset.chartId;
                userCharts = userCharts.filter(c => c.id !== chartId);
                if (chartInstances[chartId]) { chartInstances[chartId].destroy(); delete chartInstances[chartId]; }
                saveStateToLocalStorage();
                renderAllCharts();
            }));
        }

        function renderChart(config) {
            const data = filteredData;
            let chartData;
            if (config.metric === 'count') {
                const counts = data.reduce((acc, row) => { const key = row[config.groupBy] || 'N/A'; acc[key] = (acc[key] || 0) + 1; return acc; }, {});
                chartData = { labels: Object.keys(counts), values: Object.values(counts) };
            } else {
                const metrics = data.reduce((acc, row) => {
                    const key = row[config.groupBy] || 'N/A';
                    if (!acc[key]) { acc[key] = { sum: 0, count: 0 }; }
                    acc[key].sum += row[config.metric] || 0;
                    acc[key].count += 1;
                    return acc;
                }, {});
                chartData = { labels: Object.keys(metrics), values: Object.values(metrics).map(m => config.aggregation === 'sum' ? m.sum : (m.sum / m.count)) };
            }

            const ctx = getEl(config.id).getContext('2d');
            if (chartInstances[config.id]) chartInstances[config.id].destroy();
            const isBarOrLine = ['bar', 'line'].includes(config.type);
            
            chartInstances[config.id] = new Chart(ctx, {
                type: config.type,
                data: {
                    labels: chartData.labels,
                    datasets: [{ label: config.title, data: chartData.values, backgroundColor: isBarOrLine ? 'rgba(0, 123, 255, 0.7)' : ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6610f2', '#fd7e14'], borderColor: 'rgba(0, 123, 255, 1)', fill: config.type === 'line' }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: !isBarOrLine },
                        tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } let val = context.parsed.y ?? context.parsed; label += val.toLocaleString(undefined, { maximumFractionDigits: 2 }); return label; } } },
                        datalabels: { display: false }
                    },
                    scales: { x: { display: isBarOrLine }, y: { display: isBarOrLine } }
                }
            });
        }

        /**
         * Parses a simple table with months as the first column (like the circled data)
         * @param {Array<Array<any>>} sheetData - Raw data from the sheet.
         * @param {string|null} fileYear - The year extracted from the filename, for defaulting.
         * @returns {{data: Array<Object>, headers: Array<string>}} - The parsed flat data and its headers.
         */
        function parseSimpleMonthlyData(sheetData, fileYear = null) {
            try {
                if (!sheetData || !Array.isArray(sheetData) || sheetData.length === 0) {
                    throw new Error("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ä‡∏µ‡∏ï‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤");
                }

                const structuredData = [];
                
                // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÅ‡∏£‡∏Å
                let dataStartIndex = -1;
                let headerRow = null;
                
                for (let i = 0; i < Math.min(sheetData.length, 10); i++) {
                    const row = sheetData[i] || [];
                    const firstCell = String(row[0] || '').trim().toLowerCase();
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÅ‡∏£‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    const monthKeywords = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec', 'avg'];
                    if (monthKeywords.some(month => firstCell.includes(month))) {
                        dataStartIndex = i;
                        // ‡πÉ‡∏ä‡πâ‡πÅ‡∏ñ‡∏ß‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô header ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                        if (i > 0) {
                            headerRow = sheetData[i - 1];
                        }
                        break;
                    }
                }
                
                if (dataStartIndex === -1) {
                    throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á");
                }
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á headers ‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ß header ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
                const headers = ['period'];
                if (headerRow && headerRow.length > 1) {
                    for (let j = 1; j < headerRow.length; j++) {
                        const headerValue = String(headerRow[j] || '').trim();
                        if (headerValue) {
                            headers.push(headerValue);
                        } else {
                            headers.push(`Column_${j}`);
                        }
                    }
                } else {
                    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ header row ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ß‡πÅ‡∏£‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
                    const firstDataRow = sheetData[dataStartIndex];
                    for (let j = 1; j < firstDataRow.length; j++) {
                        headers.push(`Value_${j}`);
                    }
                }
                
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô flat structure
                for (let i = dataStartIndex; i < sheetData.length; i++) {
                    const row = sheetData[i] || [];
                    const firstCell = String(row[0] || '').trim();
                    
                    if (!firstCell) continue;
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    const formattedPeriod = formatPeriod(firstCell, fileYear);
                    if (!formattedPeriod) continue;
                    
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á row object
                    const dataRow = { period: formattedPeriod };
                    
                    for (let j = 1; j < headers.length && j < row.length; j++) {
                        const cellValue = row[j];
                        if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                            const numericValue = parseFloat(String(cellValue).replace(/,/g, ''));
                            dataRow[headers[j]] = !isNaN(numericValue) ? numericValue : cellValue;
                        } else {
                            dataRow[headers[j]] = null;
                        }
                    }
                    
                    structuredData.push(dataRow);
                }
                
                if (structuredData.length === 0) {
                    throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ");
                }
                
                return { data: structuredData, headers: headers };
                
            } catch (error) {
                console.error('Error in parseSimpleMonthlyData:', error);
                throw error;
            }
        }

        // --- CONFIGURATION AND STORAGE FUNCTIONS ---
        
        function saveStateToLocalStorage() {
            try {
                const state = {
                    fileName: currentFileName,
                    sheetName: currentSheetName,
                    headers: headers,
                    activeFilters: activeFilters,
                    userKPIs: userKPIs,
                    userCharts: userCharts,
                    sortKey: sortKey,
                    sortDir: sortDir,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('dashboard-state', JSON.stringify(state));
            } catch (error) {
                console.error('Error saving state to localStorage:', error);
            }
        }
        
        function loadStateFromLocalStorage() {
            try {
                const saved = localStorage.getItem('dashboard-state');
                if (saved) {
                    const state = JSON.parse(saved);
                    // Validate that the saved state matches current data
                    if (state.fileName === currentFileName && state.sheetName === currentSheetName) {
                        return state;
                    }
                }
                return null;
            } catch (error) {
                console.error('Error loading state from localStorage:', error);
                return null;
            }
        }
        
        function applyConfiguration(config) {
            try {
                if (config.activeFilters) {
                    activeFilters = [...config.activeFilters];
                    // Recreate filter UI
                    filterBuilderContainer.innerHTML = '';
                    activeFilters.forEach(filter => addFilterRow(filter));
                }
                
                if (config.userKPIs) {
                    userKPIs = [...config.userKPIs];
                }
                
                if (config.userCharts) {
                    userCharts = [...config.userCharts];
                }
                
                if (config.sortKey) {
                    sortKey = config.sortKey;
                    sortDir = config.sortDir || 'asc';
                }
                
                applyFiltersAndRender();
            } catch (error) {
                console.error('Error applying configuration:', error);
            }
        }
        
        function saveConfigToFile() {
            try {
                const config = {
                    fileName: currentFileName,
                    sheetName: currentSheetName,
                    headers: headers,
                    activeFilters: activeFilters,
                    userKPIs: userKPIs,
                    userCharts: userCharts,
                    sortKey: sortKey,
                    sortDir: sortDir,
                    exportDate: new Date().toISOString(),
                    version: "1.0"
                };
                
                const dataStr = JSON.stringify(config, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `dashboard-config-${currentSheetName}-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
            } catch (error) {
                console.error('Error saving config to file:', error);
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤: ' + error.message);
            }
        }
        
        function loadConfigFromFile(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!file.name.endsWith('.json')) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå JSON ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        // Validate config structure
                        if (!config || typeof config !== 'object') {
                            throw new Error('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                        }
                        
                        // Apply the loaded configuration
                        applyConfiguration(config);
                        saveStateToLocalStorage();
                        
                        alert('‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
                    } catch (error) {
                        console.error('Error parsing config file:', error);
                        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤: ' + error.message);
                    }
                };
                reader.readAsText(file);
                
                // Clear the input
                event.target.value = '';
            } catch (error) {
                console.error('Error loading config from file:', error);
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤: ' + error.message);
            }
        }
        
        function clearLocalStorage() {
            try {
                if (confirm('‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
                    localStorage.removeItem('dashboard-state');
                    alert('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
                    // Reset current state
                    activeFilters = [];
                    userKPIs = [];
                    userCharts = [];
                    filterBuilderContainer.innerHTML = '';
                    applyFiltersAndRender();
                }
            } catch (error) {
                console.error('Error clearing localStorage:', error);
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message);
            }
        }
        
        function exportTableToCSV() {
            try {
                if (!filteredData || filteredData.length === 0) {
                    alert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ export');
                    return;
                }
                
                // Create CSV content
                const csvHeaders = headers.join(',');
                const csvRows = filteredData.map(row => {
                    return headers.map(header => {
                        const value = row[header];
                        // Handle values that contain commas or quotes
                        if (value === null || value === undefined) return '';
                        const stringValue = String(value);
                        if (stringValue.includes(',') || stringValue.includes('"')) {
                            return `"${stringValue.replace(/"/g, '""')}"`;
                        }
                        return stringValue;
                    }).join(',');
                });
                
                const csvContent = [csvHeaders, ...csvRows].join('\n');
                
                // Add BOM for UTF-8
                const bom = '\uFEFF';
                const dataBlob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `${currentSheetName}-${new Date().toISOString().slice(0, 10)}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('Export CSV ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
            } catch (error) {
                console.error('Error exporting to CSV:', error);
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export CSV: ' + error.message);
            }
        }
        
        function exportDashboardToPDF() {
            try {
                // Note: This requires jsPDF library to be included
                if (typeof jsPDF === 'undefined') {
                    alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ jsPDF ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ export PDF\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Print ‡∏Ç‡∏≠‡∏á‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÅ‡∏ó‡∏ô');
                    window.print();
                    return;
                }
                
                // Create PDF using jsPDF (simplified version)
                const pdf = new jsPDF();
                pdf.text(`Dashboard: ${currentSheetName}`, 20, 20);
                pdf.text(`File: ${currentFileName}`, 20, 30);
                pdf.text(`Generated: ${new Date().toLocaleDateString('th-TH')}`, 20, 40);
                
                // Add KPI summary
                let yPos = 60;
                pdf.text('KPIs:', 20, yPos);
                userKPIs.forEach((kpi, index) => {
                    yPos += 10;
                    pdf.text(`${kpi.title}: ${kpi.calculation}`, 25, yPos);
                });
                
                pdf.save(`dashboard-${currentSheetName}-${new Date().toISOString().slice(0, 10)}.pdf`);
                alert('Export PDF ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
            } catch (error) {
                console.error('Error exporting to PDF:', error);
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export PDF: ' + error.message + '\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Print ‡∏Ç‡∏≠‡∏á‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÅ‡∏ó‡∏ô');
                window.print();
            }
        }

        function init() {
            Chart.register(ChartDataLabels);
            Chart.defaults.font.family = "'Sarabun', sans-serif";

            sheetSelectModal = new bootstrap.Modal(getEl('sheet-select-modal'));
            headerConfigModal = new bootstrap.Modal(getEl('header-config-modal'));
            kpiModal = new bootstrap.Modal(getEl('kpi-modal'));
            createChartModal = new bootstrap.Modal(getEl('create-chart-modal'));
            templateSelectModal = new bootstrap.Modal(getEl('template-select-modal'));

            getEl('footer-text').innerHTML = `Chatrium ¬© ${new Date().getFullYear()}`;

            excelInput.addEventListener('change', handleFileSelection);
            getEl('upload-new-button').addEventListener('click', () => { window.location.reload(); });
            getEl('add-filter-btn').addEventListener('click', () => addFilterRow());
            getEl('create-kpi-btn').addEventListener('click', openCreateKpiModal);
            getEl('save-kpi-button').addEventListener('click', saveKpi);
            getEl('create-chart-btn').addEventListener('click', openCreateChartModal);
            getEl('save-chart-button').addEventListener('click', saveChart);
            
            getEl('process-selected-sheets-btn').addEventListener('click', () => {
                const selectedSheets = Array.from(getEl('sheet-list').querySelectorAll('input:checked')).map(cb => cb.value);
                if (selectedSheets.length === 0) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏ä‡∏µ‡∏ï');
                    return;
                }
                processAndStoreSheets(selectedSheets);
            });

            getEl('next-header-config-btn').addEventListener('click', processCurrentSheetConfiguration);
            
            getEl('start-from-scratch-button').addEventListener('click', () => {
                templateSelectModal.hide();
                startHeaderConfigurationFlow(Object.keys(workbookDataStore));
            });

            getEl('save-config-btn') && getEl('save-config-btn').addEventListener('click', saveConfigToFile);
            getEl('load-config-btn') && getEl('load-config-btn').addEventListener('click', () => getEl('load-config-input').click());
            getEl('load-config-input') && getEl('load-config-input').addEventListener('change', loadConfigFromFile);
            
            const clearStorageBtn = getEl('clear-storage-btn');
            if (clearStorageBtn) clearStorageBtn.addEventListener('click', clearLocalStorage);
            
            const debugDataBtn = getEl('debug-data-btn');
            if (debugDataBtn) debugDataBtn.addEventListener('click', () => {
                console.log('üîç Manual Debug Request:');
                debugExcelData();
                debugDataInfo();
                alert('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Debug ‡∏ñ‡∏π‡∏Å‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ã‡∏•‡πÅ‡∏•‡πâ‡∏ß (‡∏Å‡∏î F12 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π)');
            });
            
            const exportCsvBtn = getEl('export-csv-btn');
            if (exportCsvBtn) exportCsvBtn.addEventListener('click', exportTableToCSV);
            
            const exportPdfBtn = getEl('export-pdf-btn');
            if (exportPdfBtn) exportPdfBtn.addEventListener('click', exportDashboardToPDF);

            tableHeaderEl.addEventListener('click', (e) => {
                const header = e.target.closest('th[data-sort-key]');
                if (!header || !header.dataset.sortKey) return;
                
                const newSortKey = header.dataset.sortKey;
                
                // Toggle sort direction if same column, otherwise start with ascending
                if (sortKey === newSortKey) {
                    sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                } else {
                    sortDir = 'asc';
                    sortKey = newSortKey;
                }
                
                // Save sort preferences
                saveStateToLocalStorage();
                
                // Apply sorting
                sortData();
                renderTableBody();
                
                // Add visual feedback
                header.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    header.style.transform = '';
                }, 100);
            });
        }
        
        init();
    </script>
</body>
</html>