<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Basic HTML Document Setup -->
    <meta charset="UTF-8"> <!-- Set character set to UTF-8 to correctly support various languages and symbols -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Set the viewport for responsive design, ensuring proper display on all devices -->
    <title>HR Data Analysis</title> <!-- The title displayed on the browser tab -->

    <!-- CSS Libraries: External stylesheets for page styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"> <!-- Bootstrap: A framework for layout, grid systems, and pre-built components -->
    <link rel="preconnect" href="https://fonts.googleapis.com"> <!-- Preconnect to the font server to reduce font loading time -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet"> <!-- Google Fonts: Using 'Sarabun' for a clean look -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"> <!-- Bootstrap Icons: A set of ready-to-use icons -->
    
    <!-- Custom Styles: Custom CSS to override or add to Bootstrap's default styles -->
    <style>
        /* Basic settings for the entire page */
        body {
            background: linear-gradient(to top, #f7f8fa 0%, #eef1f5 100%);
            font-family: 'Sarabun', sans-serif; /* Set the main font for the page */
            color: #495057;
        }
        /* Styles for the file upload box */
        .upload-container {
            max-width: 700px; /* Set a max width to keep it from getting too wide on large screens */
            margin: 5rem auto; /* Center it horizontally and add space from the top */
            padding: 2.5rem; /* Internal spacing (padding) */
            background-color: #ffffff; /* White background */
            border-radius: 1.5rem; /* Rounded corners */
            box-shadow: 0 15px 35px rgba(50,50,93,.1),0 5px 15px rgba(0,0,0,.07); /* A more prominent shadow */
            text-align: center; /* Center all text and elements inside */
            border: 1px solid #dee2e6;
        }
        /* Hide the dashboard initially */
        #dashboard-container { display: none; } /* The dashboard is hidden until a file is successfully uploaded */
        
        /* Styles for the data/chart cards */
        .card {
            border: none; /* Remove the default card border */
            box-shadow: 0 15px 35px rgba(50,50,93,.08),0 5px 15px rgba(0,0,0,.05); /* Soft shadow for cards */
            border-radius: 20px; /* Rounded corners */
            height: 100%; /* Ensures cards in the same row have equal height */
        }
        /* Styles for the card header */
        .card-header {
            background: linear-gradient(to right, #5d78ff, #4392f1); /* Vibrant blue gradient background */
            color: white; /* White text */
            font-weight: bold; /* Bold text */
            border-top-left-radius: 20px; /* Match the card's rounded corners */
            border-top-right-radius: 20px; /* Match the card's rounded corners */
            border-bottom: none; /* Remove the bottom border */
            padding: 1rem 1.5rem; /* Internal spacing */
        }
        /* Container for charts */
        .chart-container {
            position: relative; /* Set to relative for positioning the canvas inside */
            height: 350px; /* Define the height for the chart area */
            width: 100%; /* Full width of the parent (card-body) */
        }
        /* A taller container for the main staffing chart */
        .staffing-chart-container {
            position: relative;
            height: 450px; /* More height for charts with a lot of data */
            width: 100%;
        }
        /* Prompt to select a filter */
        .filter-prompt {
            min-height: 450px; /* Set a minimum height to prevent the layout from looking empty */
        }
        /* Container for scrollable tables (Service Charge, OPD) */
        .data-table-container {
            max-height: 400px; /* Set a maximum height */
            overflow-y: auto; /* Show a vertical scrollbar if the content exceeds the max height */
        }
        /* Make the Service Charge table header sticky */
        .sc-table th {
            position: sticky; /* Stick the element in place */
            top: 0; /* Stick it to the top of its container */
            background-color: #f8f9fa; /* Add a background color so it covers content scrolling underneath */
        }
        /* Styles for cells in the Service Charge table */
        .sc-table td {
            color: white; /* Text color */
            font-weight: bold; /* Bold text */
            text-align: center; /* Center align */
            vertical-align: middle; /* Middle align vertically */
        }
        /* Style for the first column (Month) of the SC table */
        .sc-table tr td:first-child {
            color: #212529; /* Change text color to black for readability */
            background-color: #f8f9fa; /* Light gray background like the header */
            font-weight: bold;
        }
        .form-select:focus, .form-control:focus {
            border-color: #5d78ff;
            box-shadow: 0 0 0 0.25rem rgba(93, 120, 255, 0.25);
        }
    </style>
</head>
<body>

    <!-- Main container for the webpage, fluid for full-screen width -->
    <div class="container-fluid p-4">
        
        <!-- Upload Section: For uploading the Excel file -->
        <div id="upload-section" class="upload-container">
            <h1 class="mb-3">HR Data Analysis</h1>
            <p class="text-muted">Please select an Excel file to begin the analysis.</p>
            <hr class="my-4">
            <!-- File input, accepts .xlsx and .xls files -->
            <input type="file" id="excel-file-input" class="form-control form-control-lg" accept=".xlsx, .xls">
            <!-- Spinner to show when loading/processing, hidden initially -->
            <div id="loading-spinner" class="text-center mt-4" style="display: none;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2">Processing file...</p>
            </div>
            <!-- Area to display errors during upload or processing -->
            <div id="upload-error" class="text-danger mt-3"></div>
        </div>

        <!-- Dashboard Section: Main display area for all charts and data, hidden initially -->
        <div id="dashboard-container">
            <!-- Dashboard header with title and reset button -->
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1 id="dashboard-title" class="mb-0">HR Dashboard</h1>
                <button id="reset-button" class="btn btn-secondary"><i class="bi bi-arrow-clockwise me-2"></i>Select New File</button>
            </div>
            <!-- The dashboard content will be dynamically generated and inserted here by JavaScript -->
            <div id="dashboard-content"></div> 
        </div>
    </div>

    <!-- JS Libraries: External JavaScript files -->
    <script src="https://code.jquery.com/jquery-3.7.1.js"></script> <!-- jQuery: Popular library that simplifies DOM manipulation, events, and Ajax -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script> <!-- Bootstrap's JS for interactive components like dropdowns and modals -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Chart.js: The main library for creating various types of charts -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script> <!-- A Chart.js plugin to display data labels on charts -->
    <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script> <!-- SheetJS (xlsx): A library for reading and writing Excel files on the client-side (browser) -->

    <script>
    // $(function() { ... }) is jQuery's shorthand for $(document).ready()
    // This ensures that all JavaScript code inside this block runs only after the page's DOM is fully loaded.
    $(function() {
        // --- INITIAL SETUP ---
        Chart.register(ChartDataLabels);
        Chart.defaults.font.family = "'Sarabun', sans-serif";
        Chart.defaults.plugins.datalabels.color = '#333';
        Chart.defaults.plugins.datalabels.font.weight = 'bold';
        
        // Increase tooltip font size globally
        Chart.defaults.plugins.tooltip.titleFont = {
            size: 16,
            weight: 'bold',
            family: "'Sarabun', sans-serif"
        };
        Chart.defaults.plugins.tooltip.bodyFont = {
            size: 14,
            family: "'Sarabun', sans-serif"
        };
        Chart.defaults.plugins.tooltip.padding = 10;


        // --- GLOBAL VARIABLES ---
        let chartInstances = {}; 
        let allParsedData = [];      
        let allTurnoverData = [];   
        let allServiceChargeData = []; 
        let allOpdData = [];       

        // --- CONSTANTS ---
        const HOTEL_CODES = ['CHRB', 'CRRB', 'CRST', 'ES', 'CGB', 'MHSC', 'MHRB', 'MMSB', 'SDAO', 'LKYT', 'CHRY', 'CNSJ', 'CHH'];
        const EMPLOYMENT_TYPES = ['FT', 'CT', 'OS'];
        const STAFFING_DEPARTMENTS = ['FO', 'HKP', 'Laundry', 'Fitness', 'F&B Service', 'Kitchen', 'A&G', 'Finance', 'Procurement', 'IT', 'HR', 'Security', 'Sales', 'Engineering', 'MarComm', 'E-Commerce', 'Commercial', 'Service Quality Assurance', 'Golf Operations', 'Golf Maintenance', 'Test'];
        const STAFFING_DEPARTMENT_SET = new Set(STAFFING_DEPARTMENTS.map(dept => dept.toUpperCase())); 
        const CHART_COLORS = ['#5e72e4', '#2dce89', '#11cdef', '#fb6340', '#f5365c', '#8898aa', '#32325d', '#212529', '#6610f2', '#e83e8c', '#adb5bd', '#32325d'];

        // --- EVENT HANDLERS ---
        $('#reset-button').on('click', resetToUpload); 
        $('#excel-file-input').on('change', handleFileAnalysis); 

        /**
         * @name handleFileAnalysis
         * @description Main function to handle the user-uploaded Excel file. It manages reading the file, parsing data, rendering the dashboard, and handling errors.
         * @param {Event} event - The event object, which contains file information in event.target.files.
         */
        async function handleFileAnalysis(event) {
            const file = event.target.files[0]; 
            if (!file) return; 
            
            $('#loading-spinner').show();
            $('#upload-error').text('');
            
            try {
                const data = await file.arrayBuffer(); 
                const workbook = XLSX.read(data, { type: 'array', cellDates: true }); 

                // Clear old data
                allParsedData = [];
                allTurnoverData = [];
                allServiceChargeData = [];
                allOpdData = [];

                // Process Staffing (first sheet)
                const staffingSheetName = workbook.SheetNames[0]; 
                if (staffingSheetName) {
                    try { 
                        const worksheet = workbook.Sheets[staffingSheetName];
                        const dataAsArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null, raw: false });
                        allParsedData = parseMultiLevelHeaderData(dataAsArray); 
                    } catch (e) { console.warn("Could not parse staffing data:", e.message); } 
                }

                // Process Turnover
                const turnoverSheetName = workbook.SheetNames.find(name => name.toLowerCase().trim() === 'turnover');
                if (turnoverSheetName) {
                    try {
                        const worksheet = workbook.Sheets[turnoverSheetName];
                        const dataAsArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null, raw: false });
                        allTurnoverData = parseGenericMonthlyData(dataAsArray, 'turnover');
                    } catch (e) { console.warn("Could not parse Turnover sheet:", e.message); }
                }
                
                // Process Service Charge
                const serviceChargeSheetName = workbook.SheetNames.find(name => name.toLowerCase().trim().replace(/ /g,'') === 'servicecharge');
                if (serviceChargeSheetName) {
                    try {
                        const worksheet = workbook.Sheets[serviceChargeSheetName];
                        const dataAsArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null, raw: false });
                        allServiceChargeData = parseGenericMonthlyData(dataAsArray, 'service_charge');
                    } catch (e) { console.warn("Could not parse Service Charge sheet:", e.message); }
                }

                // Process ALL sheets starting with "OPD"
                const opdSheetNames = workbook.SheetNames.filter(name => name.toLowerCase().trim().startsWith('opd'));
                opdSheetNames.forEach(sheetName => {
                    try {
                        const worksheet = workbook.Sheets[sheetName];
                        const dataAsArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null, raw: false });
                        const parsedOpd = parseOpdData(dataAsArray, sheetName);
                        allOpdData.push(...parsedOpd); // Add data from this sheet to the main OPD array
                    } catch (e) { 
                        console.warn(`Could not parse OPD sheet: "${sheetName}"`, e.message); 
                    }
                });


                if (allParsedData.length === 0 && allTurnoverData.length === 0 && allServiceChargeData.length === 0 && allOpdData.length === 0) {
                    throw new Error("Could not find any analyzable data in the file (Staffing, Turnover, Service Charge, or OPD).");
                }

                $('#upload-section').hide();
                $('#dashboard-container').show();
                renderDashboard();

            } catch(error) {
                console.error("Error during analysis:", error); 
                $('#upload-error').html(`<p class="text-danger">${error.message}</p>`); 
            } finally {
                $('#loading-spinner').hide();
            }
        }
        
        // --- DATA PARSING FUNCTIONS ---

        /**
         * @name parseMultiLevelHeaderData
         * @description Parses Staffing sheet data with a complex, multi-level header structure.
         */
        function parseMultiLevelHeaderData(sheetData) {
            const structuredData = [];
            let hotelRowIndex = -1, typeRowIndex = -1, periodRowIndex = -1;
            const upperHotelCodes = HOTEL_CODES.map(c => c.toUpperCase());
            for(let i = 0; i < 20 && i < sheetData.length; i++) {
                const row = sheetData[i] || [];
                if (hotelRowIndex === -1 && row.some(cell => upperHotelCodes.includes(String(cell || '').trim().toUpperCase()))) hotelRowIndex = i;
                if (typeRowIndex === -1 && row.some(cell => EMPLOYMENT_TYPES.includes(String(cell || '').trim().toUpperCase()))) typeRowIndex = i;
                if (periodRowIndex === -1 && row.some(cell => formatPeriod(cell))) periodRowIndex = i;
            }
            if(hotelRowIndex === -1 || typeRowIndex === -1 || periodRowIndex === -1) throw new Error("Staffing: Could not find the required header rows (Hotel, Type, or Period).");
            
            const columnContextMap = new Map();
            const hotelRow = sheetData[hotelRowIndex], typeRow = sheetData[typeRowIndex], periodRow = sheetData[periodRowIndex];
            const maxCols = Math.max((hotelRow || []).length, (typeRow || []).length, (periodRow || []).length);
            
            const findLastValidValue = (row, colIndex, validSet) => {
                for (let k = colIndex; k >= 0; k--) {
                    const cellValue = String((row || [])[k] || '').trim().toUpperCase();
                    const foundValue = validSet.find(v => v.toUpperCase() === cellValue);
                    if (foundValue) return foundValue;
                }
                return null;
            };

            for (let j = 1; j < maxCols; j++) {
                const currentHotel = findLastValidValue(hotelRow, j, HOTEL_CODES);
                const currentType = findLastValidValue(typeRow, j, EMPLOYMENT_TYPES);
                let periodCell = periodRow[j];
                let formattedPeriod = formatPeriod(periodCell)
                
                if (formattedPeriod && currentHotel && currentType) {
                    columnContextMap.set(j, { hotel: currentHotel, type: currentType, period: formattedPeriod });
                }
            }
            
            for (let i = periodRowIndex + 1; i < sheetData.length; i++) {
                const row = sheetData[i] || [];
                const rawDeptName = String(row[0] || '').trim();
                if (!rawDeptName || !STAFFING_DEPARTMENT_SET.has(rawDeptName.toUpperCase())) continue;
                
                columnContextMap.forEach((context, colIndex) => {
                    const numericValue = parseFloat(row[colIndex]);
                    if (!isNaN(numericValue) && isFinite(numericValue)) {
                        structuredData.push({ ...context, department: rawDeptName, value: numericValue });
                    }
                });
            }
            return structuredData;
        }

        /**
         * @name parseGenericMonthlyData
         * @description A generic function to parse simple monthly data (e.g. Turnover, Service Charge).
         */
        function parseGenericMonthlyData(sheetData, valueKey) {
            const parsedData = [];
            let headerRowIndex = -1, periodColIndex = -1;
            const upperHotelCodes = HOTEL_CODES.map(h => h.toUpperCase());
            const searchLimit = Math.min(15, sheetData.length);

            let bestHeaderMatch = { index: -1, count: 0 };
            for (let i = 0; i < searchLimit; i++) {
                const row = sheetData[i] || [];
                const headerCount = row.filter(cell => upperHotelCodes.includes(String(cell || '').trim().toUpperCase())).length;
                if (headerCount > 1 && headerCount > bestHeaderMatch.count) {
                    bestHeaderMatch = { index: i, count: headerCount };
                }
            }
            headerRowIndex = bestHeaderMatch.index;
            if (headerRowIndex === -1) throw new Error(`${valueKey}: Could not find the hotel header row.`);

            let bestPeriodMatch = { index: -1, count: 0 };
            for (let j = 0; j < Math.min(10, (sheetData[headerRowIndex] || []).length); j++) {
                let periodCount = 0;
                for (let i = headerRowIndex + 1; i < searchLimit; i++) {
                    if (formatPeriod((sheetData[i] || [])[j])) periodCount++;
                }
                if (periodCount > bestPeriodMatch.count) bestPeriodMatch = { index: j, count: periodCount };
            }
            periodColIndex = bestPeriodMatch.index;
            if (periodColIndex === -1) periodColIndex = 0; 

            const headerRow = sheetData[headerRowIndex] || [];
            for (let i = headerRowIndex + 1; i < sheetData.length; i++) {
                const row = sheetData[i] || [];
                const periodCell = row[periodColIndex];
                
                let finalPeriod = formatPeriod(periodCell);
                if (!finalPeriod) continue; // Skip rows that don't have a valid period

                for (let j = 0; j < headerRow.length; j++) {
                    if (j === periodColIndex) continue;
                    const headerUpper = String(headerRow[j] || '').trim().toUpperCase();
                    if (!upperHotelCodes.includes(headerUpper)) continue; 
                    
                    const rawValue = row[j];
                    let finalValue;
                    if (typeof rawValue === 'number') {
                        finalValue = (valueKey === 'turnover' && rawValue < 1 && rawValue > 0) ? rawValue * 100 : rawValue;
                    } else if (typeof rawValue === 'string' && rawValue.trim() !== '') {
                        finalValue = parseFloat(rawValue.replace(/[%,]/g, ''));
                    } else {
                        finalValue = parseFloat(rawValue);
                    }
                    if (!isNaN(finalValue) && isFinite(finalValue)) {
                        parsedData.push({ hotel: headerUpper, period: finalPeriod, [valueKey]: finalValue });
                    }
                }
            }
            return parsedData;
        }

        /**
         * @name parseOpdData
         * @description Parses data from an OPD sheet and adds a period extracted from the sheet name.
         * @param {Array<Array<any>>} sheetData - Raw data from the sheet.
         * @param {string} sheetName - The name of the sheet to extract the period from.
         * @returns {Array<Object>} - The parsed data.
         */
        function parseOpdData(sheetData, sheetName) {
            const parsedData = [];
            
            // --- MODIFIED: More robust regex to find any valid month name in the sheet title ---
            const monthMatch = sheetName.match(/(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|Nov(ember)?|Dec(ember)?)/i);
            
            if (!monthMatch) {
                // If no recognizable month is found, we cannot proceed.
                throw new Error(`Could not determine a valid month from OPD sheet name: "${sheetName}"`);
            }
            
            // Standardize month to 3 letters, e.g., "January" -> "Jan"
            const month = monthMatch[1].charAt(0).toUpperCase() + monthMatch[1].slice(1, 3).toLowerCase();
            
            // Look for a 2 or 4 digit year in the sheet name
            const yearMatch = sheetName.match(/(\d{2,4})/);
            // If a year is found, use its last two digits. Otherwise, default to the current year.
            const year = yearMatch ? String(yearMatch[1]).slice(-2) : new Date().getFullYear().toString().slice(-2);
            
            const period = `${month}-${year}`;

            const headerKeys = {
                "hotel": "hotel", "noofemployee": "noOfEmployee", "medical": "medical",
                "dental": "dental", "totalclaims": "totalClaims", "avgperhead": "avgPerHead"
            };

            let headerRowIndex = -1;
            for (let i = 0; i < 10 && i < sheetData.length; i++) {
                const row = sheetData[i] || [];
                const normalizedRow = row.map(cell => String(cell || '').toLowerCase().replace(/[\s-]/g, ''));
                let matchCount = 0;
                Object.keys(headerKeys).forEach(key => {
                    if (normalizedRow.includes(key)) matchCount++;
                });
                if (matchCount >= 4) { headerRowIndex = i; break; }
            }
            if (headerRowIndex === -1) throw new Error(`OPD (${period}): Could not find header row.`);

            const headerRow = sheetData[headerRowIndex];
            const colIndexMap = {};
            const upperHotelCodes = HOTEL_CODES.map(h => h.toUpperCase());

            headerRow.forEach((cell, index) => {
                const normalizedCell = String(cell || '').toLowerCase().replace(/[\s-]/g, '');
                const matchedKey = Object.keys(headerKeys).find(key => key === normalizedCell);
                if (matchedKey) colIndexMap[headerKeys[matchedKey]] = index;
            });
            if (colIndexMap['hotel'] === undefined || colIndexMap['totalClaims'] === undefined) {
                 throw new Error(`OPD (${period}): Missing 'Hotel' or 'Total Claims' columns.`);
            }

            for (let i = headerRowIndex + 1; i < sheetData.length; i++) {
                const row = sheetData[i] || [];
                const hotelName = String(row[colIndexMap['hotel']] || '').trim().toUpperCase();
                if (!hotelName || hotelName.includes('TOTAL') || hotelName === "") continue;

                if (upperHotelCodes.includes(hotelName)) {
                    const dataEntry = { hotel: hotelName, period: period };
                    Object.keys(colIndexMap).forEach(key => {
                        if (key !== 'hotel') {
                            const val = parseFloat(String(row[colIndexMap[key]] || '0').replace(/,/g, ''));
                            dataEntry[key] = isNaN(val) ? 0 : val;
                        }
                    });
                    parsedData.push(dataEntry);
                }
            }
            return parsedData;
        }


        // --- DASHBOARD RENDERING & UPDATES ---

        /**
         * @name renderDashboard
         * @description Creates the initial HTML structure of the dashboard and sets up event handlers.
         */
        function renderDashboard() {
            destroyAllCharts();
            const content = `
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-body">
                                <label for="period-filter" class="form-label fw-bold">1. Select Main Data View</label>
                                <select id="period-filter" class="form-select form-select-lg border-primary"></select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-body">
                                <p class="form-label fw-bold">2. Secondary Filters (Optional)</p>
                                <div class="row g-3 align-items-end">
                                    <div class="col-md-4">
                                        <label for="hotel-filter" class="form-label">Hotel</label>
                                        <select id="hotel-filter" class="form-select"></select>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="type-filter" class="form-label">Employee Type</label>
                                        <select id="type-filter" class="form-select"></select>
                                    </div>
                                    <div class="col-md-4">
                                        <button id="clear-secondary-filters" class="btn btn-outline-secondary w-100"><i class="bi bi-x-circle me-2"></i>Clear Filters</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="main-content-area"></div>`;

            $('#dashboard-content').html(content);
            populateFilters();
            
            // Setup event handlers
            $('#dashboard-content').off('change'); // Clear all previous change handlers
            $('#dashboard-content').on('change', '#period-filter, #hotel-filter, #type-filter, #department-filter', updateDashboardView);
            $('#dashboard-content').on('change', '#opd-metric-filter, #opd-month-filter', drawOpdContent); 

            $('#dashboard-content').off('click', '#clear-secondary-filters').on('click', '#clear-secondary-filters', () => {
                $('#hotel-filter, #type-filter, #department-filter').prop('selectedIndex', 0);
                updateDashboardView();
            });
            
            updateDashboardView();
        }
        
        /**
         * @name populateFilters
         * @description Populates filter dropdowns with options based on parsed data.
         */
        function populateFilters() {
            const allHotels = [...new Set([
                ...allParsedData.map(d => d.hotel), ...allTurnoverData.map(d => d.hotel), 
                ...allServiceChargeData.map(d => d.hotel), ...allOpdData.map(d => d.hotel)
            ])].sort();
            const types = ['All', ...[...new Set(allParsedData.map(d => d.type))].sort()];
            
            // Get all unique periods from all data sources and sort them
            const allPeriods = [...new Set([
                ...allParsedData.map(d => d.period), ...allTurnoverData.map(d => d.period),
                ...allServiceChargeData.map(d => d.period), ...allOpdData.map(d => d.period)
            ])].filter(p => p).sort((a, b) => parsePeriodToDate(a) - parsePeriodToDate(b)); // Filter out null/empty periods
            
            $('#hotel-filter').html(['All', ...allHotels].map(h => `<option value="${h}">${h}</option>`).join(''));
            $('#type-filter').html(types.map(t => `<option value="${t}">${t}</option>`).join(''));
            
            let periodOptions = `<option value="" disabled selected>--- Please Select a View ---</option>`;
            if (allOpdData.length > 0) periodOptions += `<option value="ALL_OPD">Overall OPD</option>`;
            if (allServiceChargeData.length > 0) periodOptions += `<option value="ALL_SERVICE_CHARGE">Overall Service Charge</option>`;
            if (allTurnoverData.length > 0) periodOptions += `<option value="ALL_TURNOVER">Overall Turnover</option>`;
            periodOptions += allPeriods.map(p => `<option value="${p}">Monthly Data for ${p}</option>`).join('');
            $('#period-filter').html(periodOptions);
        }

        /**
         * @name updateDashboardView
         * @description Main controller for the dashboard display based on filter selections.
         */
        function updateDashboardView() {
            const currentDept = $('#department-filter').val();
            $('#main-content-area').empty();
            const selectedPeriod = $('#period-filter').val();

            if (selectedPeriod) {
                $('#type-filter').parent().toggle(selectedPeriod !== 'ALL_OPD' && selectedPeriod !== 'ALL_SERVICE_CHARGE' && selectedPeriod !== 'ALL_TURNOVER');
                 $('#hotel-filter').parent().toggle(selectedPeriod !== 'ALL_SERVICE_CHARGE');

                if (selectedPeriod === 'ALL_TURNOVER') {
                        $('#main-content-area').append(`<div id="turnover-section" class="row mt-4"></div>`);
                        updateTurnoverSection();
                } else if (selectedPeriod === 'ALL_SERVICE_CHARGE') {
                        $('#main-content-area').append(`<div id="sc-section" class="row mt-4"></div>`);
                        updateServiceChargeSection();
                } else if (selectedPeriod === 'ALL_OPD') {
                        $('#main-content-area').append(`<div id="opd-section-wrapper" class="mt-4"></div>`);
                        renderOverallOpdView();
                } else {
                    // Monthly View
                    if (allParsedData.filter(d => d.period === selectedPeriod).length > 0) {
                        $('#main-content-area').append(`<div id="staffing-section"></div>`);
                        updateStaffingCharts(currentDept);
                    }
                    if (allTurnoverData.filter(d => d.period === selectedPeriod).length > 0) {
                        $('#main-content-area').append(`<div id="turnover-section" class="row mt-4"></div>`);
                        updateTurnoverSection();
                    }
                    if (allOpdData.filter(d => d.period === selectedPeriod).length > 0) {
                         $('#main-content-area').append(`<div id="opd-section-wrapper" class="mt-4"></div>`);
                         renderMonthlyOpdView();
                    }
                }
            } else {
                $('#type-filter').parent().show();
                 $('#hotel-filter').parent().show();
                $('#main-content-area').append(`<div id="initial-prompt" class="d-flex align-items-center justify-content-center text-muted filter-prompt"><h4><i class="bi bi-arrow-up-circle-fill me-2"></i>Please select a view from the menu above</h4></div>`);
            }
        }

        /**
         * @name updateStaffingCharts
         * @description Updates the Staffing data section.
         */
        function updateStaffingCharts(currentDeptValue) {
            const staffingHtml = `
                <div class="row">
                    <div class="col-lg-8 mb-4"><div class="card"><div class="card-header" id="department-chart-title"></div><div class="card-body"><div class="staffing-chart-container"><canvas id="department-chart"></canvas></div></div></div></div>
                    <div class="col-lg-4 mb-4"><div class="card"><div class="card-header">Summary Table</div><div class="card-body"><div class="table-responsive" style="max-height: 450px;"><table class="table table-striped"><thead><tr><th>Department</th><th>Count</th></tr></thead><tbody id="summary-table-body"></tbody><tfoot class="fw-bold"><tr><td>Total</td><td id="summary-table-total"></td></tr></tfoot></table></div></div></div></div>
                </div>
                <div class="row mb-4">
                    <div class="col-md-5"><label for="department-filter" class="form-label fw-bold">Filter by Department (for chart below)</label><select id="department-filter" class="form-select"></select></div>
                </div>
                <div class="row"><div class="col-12 mb-4"><div class="card"><div class="card-header" id="monthly-chart-title"></div><div class="card-body"><div class="chart-container" style="height: 300px;"><canvas id="monthly-chart"></canvas></div></div></div></div></div>`;
            $('#staffing-section').html(staffingHtml);
            
            const selectedHotel = $('#hotel-filter').val();
            const selectedType = $('#type-filter').val();
            const selectedPeriod = $('#period-filter').val();
            
            // Populate department filter
            const departments = ['All', ...[...new Set(allParsedData.map(d => d.department))].sort()];
            $('#department-filter').html(departments.map(d => `<option value="${d}" ${d === currentDeptValue ? 'selected' : ''}>${d}</option>`).join(''));
            const selectedDepartment = $('#department-filter').val();

            // Department chart
            const departmentFilteredData = allParsedData.filter(d => (selectedHotel === 'All' || d.hotel === selectedHotel) && (selectedType === 'All' || d.type === selectedType) && d.period === selectedPeriod);
            const departmentTotals = departmentFilteredData.reduce((acc, item) => { acc[item.department] = (acc[item.department] || 0) + item.value; return acc; }, {});
            const sortedDepartments = Object.entries(departmentTotals).sort(([, a], [, b]) => b - a);
            updateBarChart('department-chart', 'bar', sortedDepartments.map(d => d[0]), sortedDepartments.map(d => d[1]), '#5e72e4', 'y');
            
            // Summary table
            const tableBody = $('#summary-table-body').empty();
            let total = 0;
            if(sortedDepartments.length === 0){ tableBody.html('<tr><td colspan="2" class="text-center text-muted">No data found</td></tr>'); }
            else { sortedDepartments.forEach(([dept, value]) => { tableBody.append(`<tr><td>${dept}</td><td>${value.toLocaleString()}</td></tr>`); total += value; });}
            $('#summary-table-total').text(total.toLocaleString());

            // Monthly trend chart
            const monthlyFilteredData = allParsedData.filter(d => (selectedHotel === 'All' || d.hotel === selectedHotel) && (selectedType === 'All' || d.type === selectedType) && (selectedDepartment === 'All' || !selectedDepartment || d.department === selectedDepartment));
            const monthlyTotals = monthlyFilteredData.reduce((acc, item) => { acc[item.period] = (acc[item.period] || 0) + item.value; return acc; }, {});
            const sortedMonths = Object.entries(monthlyTotals).sort((a, b) => parsePeriodToDate(a[0]) - parsePeriodToDate(b[0]));
            updateBarChart('monthly-chart', 'bar', sortedMonths.map(d => d[0]), sortedMonths.map(d => d[1]), '#2dce89', 'x');

            // Update titles
            const format = (val, defaultVal) => (val === 'All' || !val) ? defaultVal : val;
            $('#department-chart-title').text(`Staffing by Department (${format(selectedHotel, 'All Hotels')}, ${format(selectedType, 'All Types')}, ${format(selectedPeriod, '')})`);
            $('#monthly-chart-title').text(`Total Staffing per Month (${format(selectedHotel, 'All Hotels')}, Dept: ${format(selectedDepartment, 'All')})`);
        }

        /**
         * @name updateTurnoverSection
         * @description Updates the Turnover data section.
         */
        function updateTurnoverSection() {
            const selectedHotel = $('#hotel-filter').val();
            const selectedPeriod = $('#period-filter').val();

            if (selectedPeriod && selectedPeriod !== 'ALL_TURNOVER' && selectedPeriod !== 'ALL_SERVICE_CHARGE' && selectedPeriod !== 'ALL_OPD') {
                const turnoverHtml = `<div class="col-lg-8 mb-4"><div class="card h-100"><div class="card-header" id="turnover-chart-title"></div><div class="card-body"><div class="chart-container"><canvas id="turnover-chart"></canvas></div></div></div></div><div class="col-lg-4 mb-4"><div class="card h-100"><div class="card-header">Turnover Summary</div><div class="card-body data-table-container"><table class="table table-striped"><thead><tr><th>Hotel</th><th>Turnover Rate</th></tr></thead><tbody id="turnover-summary-table-body"></tbody></table></div></div></div>`;
                $('#turnover-section').html(turnoverHtml);

                const periodData = allTurnoverData.filter(d => d.period === selectedPeriod);
                let filteredData = (selectedHotel === 'All') ? periodData : periodData.filter(d => d.hotel === selectedHotel);
                filteredData.sort((a, b) => b.turnover - a.turnover);

                updateSimpleBarChartWithPercent('turnover-chart', 'bar', filteredData.map(d => d.hotel), filteredData.map(d => d.turnover), 'rgba(251, 99, 64, 0.7)', 'y');
                $('#turnover-chart-title').text(`Turnover Rate for ${selectedPeriod}`);

                const tableBody = $('#turnover-summary-table-body').empty();
                if (filteredData.length === 0) { tableBody.html('<tr><td colspan="2" class="text-center text-muted">No data found</td></tr>'); } 
                else { filteredData.forEach(d => { tableBody.append(`<tr><td>${d.hotel}</td><td>${d.turnover.toFixed(1)}%</td></tr>`); });}
            } else { // Overall view
                const turnoverHtml = `<div class="col-12 mb-4"><div class="card"><div class="card-header" id="turnover-table-title"></div><div class="card-body data-table-container"><table class="table table-bordered table-sm"><thead id="turnover-table-head"></thead><tbody id="turnover-table-body"></tbody></table></div></div></div><div class="col-12 mb-4"><div class="card"><div class="card-header" id="turnover-chart-title"></div><div class="card-body"><div class="chart-container" style="height: 500px;"><canvas id="turnover-chart"></canvas></div></div></div></div>`;
                $('#turnover-section').html(turnoverHtml);

                let filteredData = (selectedHotel === 'All') ? allTurnoverData : allTurnoverData.filter(d => d.hotel === selectedHotel);
                const allPeriods = [...new Set(filteredData.map(d => d.period))].sort((a, b) => parsePeriodToDate(a) - parsePeriodToDate(b));
                const hotelsInSelection = [...new Set(filteredData.map(d => d.hotel))].sort();

                let tableHead = `<tr><th>Month</th>${hotelsInSelection.map(h => `<th>${h}</th>`).join('')}</tr>`;
                $('#turnover-table-head').html(tableHead);

                let tableBody = allPeriods.map(p => {
                    let rowHtml = `<tr><td class="text-nowrap" style="background-color: #f8f9fa; color: #212529; font-weight: bold;">${p}</td>`;
                    hotelsInSelection.forEach(h => {
                        const entry = filteredData.find(d => d.period === p && d.hotel === h);
                        rowHtml += `<td style="text-align:center;">${entry ? entry.turnover.toFixed(1) + '%' : '-'}</td>`;
                    });
                    return rowHtml + `</tr>`;
                }).join('');
                $('#turnover-table-body').html(tableBody);
                $('#turnover-table-title').text(`Turnover Rate Table (${selectedHotel === 'All' ? 'All Hotels' : selectedHotel})`);

                const datasets = hotelsInSelection.map((hotel, index) => ({
                    label: hotel,
                    data: allPeriods.map(p => filteredData.find(d => d.period === p && d.hotel === hotel)?.turnover || null),
                    backgroundColor: CHART_COLORS[index % CHART_COLORS.length],
                    borderColor: CHART_COLORS[index % CHART_COLORS.length],
                    fill: false,
                    tension: 0.1
                }));
                updateGroupedBarChart('turnover-chart', allPeriods, datasets, { isPercentage: true });
                $('#turnover-chart-title').text(`Monthly Turnover Rate (${selectedHotel === 'All' ? 'All Hotels' : selectedHotel})`);
            }
        }

        /**
         * @name updateServiceChargeSection
         * @description Updates the Service Charge section. This is always an "overall" view.
         */
        function updateServiceChargeSection() {
            const scHtml = `<div class="col-12 mb-4"><div class="card"><div class="card-header" id="sc-table-title">Monthly Service Charge</div><div class="card-body data-table-container sc-table-container"><table class="table table-bordered table-sm sc-table"><thead id="sc-table-head"></thead><tbody id="sc-table-body"></tbody></table></div></div></div><div class="col-12 mb-4"><div class="card"><div class="card-header">Average Service Charge</div><div class="card-body"><div class="chart-container" style="height: 450px;"><canvas id="avg-sc-chart"></canvas></div></div></div></div>`;
            $('#sc-section').html(scHtml);
            
            const hotels = [...new Set(allServiceChargeData.map(d => d.hotel))].sort();
            const periods = [...new Set(allServiceChargeData.map(d => d.period))].sort((a,b) => parsePeriodToDate(a) - parsePeriodToDate(b));
            
            let tableHead = `<tr><th>Month</th>`;
            hotels.forEach(h => tableHead += `<th>${h}</th>`);
            tableHead += `</tr>`;
            $('#sc-table-head').html(tableHead);
            
            const allValues = allServiceChargeData.map(d => d.service_charge);
            const min = Math.min(...allValues), max = Math.max(...allValues);

            let tableBody = periods.map(p => {
                let rowHtml = `<tr><td>${p}</td>`;
                hotels.forEach(h => {
                    const entry = allServiceChargeData.find(d => d.period === p && d.hotel === h);
                    const value = entry ? entry.service_charge : null;
                    const color = value !== null ? getColorForValue(value, min, max) : '#ffffff';
                    const textColor = value !== null ? '#ffffff' : '#212529';
                    rowHtml += `<td style="background-color:${color}; color:${textColor}">${value ? value.toLocaleString() : '-'}</td>`;
                });
                return rowHtml + `</tr>`;
            }).join('');
            $('#sc-table-body').html(tableBody);

            const avgDataMap = new Map();
            allServiceChargeData.forEach(d => {
                if (!avgDataMap.has(d.hotel)) avgDataMap.set(d.hotel, { sum: 0, count: 0 });
                const current = avgDataMap.get(d.hotel);
                current.sum += d.service_charge;
                current.count++;
            });
            const avgData = Array.from(avgDataMap, ([hotel, {sum, count}]) => ({ hotel, service_charge: sum / count }));
            const sortedAvgData = avgData.sort((a,b) => b.service_charge - a.service_charge);
            updateBarChart('avg-sc-chart', 'bar', sortedAvgData.map(d => d.hotel), sortedAvgData.map(d => d.service_charge), '#6f42c1', 'y');
        }

        /**
         * @name renderMonthlyOpdView
         * @description Renders the OPD view for a single, specific month.
         */
        function renderMonthlyOpdView() {
            const selectedPeriod = $('#period-filter').val();
            const opdHtml = `
                <div class="row">
                    <div class="col-12 mb-4">
                        <div class="card">
                            <div class="card-body pb-0">
                                <div class="row align-items-end">
                                    <div class="col-md-5">
                                        <label for="opd-metric-filter" class="form-label fw-bold">Metric</label>
                                        <select id="opd-metric-filter" class="form-select mb-3">
                                            <option value="totalClaims" selected>Total Claims</option>
                                            <option value="medical">Medical</option><option value="dental">Dental</option>
                                            <option value="avgPerHead">Average Per Head</option><option value="noOfEmployee">No. of Employees</option>
                                        </select>
                                    </div>
                                    <div class="col-md-7"><h4 class="text-end text-muted mb-3">OPD Summary for ${selectedPeriod}</h4></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="opd-dynamic-content" class="col-12"></div>
                </div>`;
            $('#opd-section-wrapper').html(opdHtml);
            drawOpdContent();
        }
        
        /**
         * @name renderOverallOpdView
         * @description Renders the OPD trend view, now with a month filter.
         */
        function renderOverallOpdView() {
            const opdHtml = `
                <div class="row">
                    <div class="col-12 mb-4">
                         <div class="card"><div class="card-body pb-0"><div class="row align-items-center">
                            <div class="col-md-5">
                                <label for="opd-metric-filter" class="form-label fw-bold">Metric</label>
                                <select id="opd-metric-filter" class="form-select">
                                    <option value="totalClaims" selected>Total Claims</option>
                                    <option value="medical">Medical</option><option value="dental">Dental</option>
                                    <option value="avgPerHead">Average Per Head</option><option value="noOfEmployee">No. of Employees</option>
                                </select>
                            </div>
                            <div class="col-md-5">
                                <label for="opd-month-filter" class="form-label fw-bold">Filter by Month</label>
                                <select id="opd-month-filter" class="form-select"></select>
                            </div>
                        </div></div></div>
                    </div>
                    <div id="opd-dynamic-content" class="col-12"></div>
                </div>`;
            $('#opd-section-wrapper').html(opdHtml);
            
            // Populate the new month filter
            const opdMonths = ['All Months', ...[...new Set(allOpdData.map(d => d.period))].sort((a,b) => parsePeriodToDate(a) - parsePeriodToDate(b))];
            $('#opd-month-filter').html(opdMonths.map(m => `<option value="${m}">${m}</option>`).join(''));
            
            drawOpdContent(); // Initial draw
        }


        /**
         * @name drawOpdContent
         * @description Draws or updates the OPD content (table and chart) based on current filter selections.
         */
        function drawOpdContent() {
            const mainFilterPeriod = $('#period-filter').val();
            const opdMonthFilter = $('#opd-month-filter').val() || 'All Months';
            const selectedMetric = $('#opd-metric-filter').val();
            const metricLabel = $('#opd-metric-filter option:selected').text();
            const selectedHotel = $('#hotel-filter').val();

            let dataToDisplay = allOpdData;
            let isSingleMonthView = false;
            
            // Determine the period to filter by
            let filterPeriod = null;
            if (mainFilterPeriod === 'ALL_OPD') {
                if (opdMonthFilter !== 'All Months') {
                    filterPeriod = opdMonthFilter;
                    isSingleMonthView = true;
                }
            } else {
                filterPeriod = mainFilterPeriod;
                isSingleMonthView = true;
            }

            // Filter data based on hotel and period
            if (selectedHotel !== 'All') {
                dataToDisplay = dataToDisplay.filter(d => d.hotel === selectedHotel);
            }
            if (filterPeriod) {
                dataToDisplay = dataToDisplay.filter(d => d.period === filterPeriod);
            }
            
            // Render content based on view type
            if (isSingleMonthView) {
                // RENDER SINGLE MONTH VIEW
                const singleMonthHtml = `
                    <div class="row">
                        <div class="col-lg-7 mb-4">
                            <div class="card"><div class="card-header" id="opd-table-title"></div>
                                <div class="card-body data-table-container"><table class="table table-striped table-hover">
                                    <thead><tr>
                                        <th>Hotel</th><th class="text-end">Employees</th><th class="text-end">Medical</th>
                                        <th class="text-end">Dental</th><th class="text-end">Total Claims</th><th class="text-end">Avg/Head</th>
                                    </tr></thead><tbody id="opd-table-body"></tbody>
                                </table></div>
                            </div>
                        </div>
                        <div class="col-lg-5 mb-4"><div class="card"><div class="card-header" id="opd-chart-title"></div>
                            <div class="card-body d-flex align-items-center"><div class="chart-container" style="height: 450px;"><canvas id="opd-chart"></canvas></div></div>
                        </div></div>
                    </div>`;
                const container = $('#opd-section-wrapper #opd-dynamic-content').length ? $('#opd-section-wrapper #opd-dynamic-content') : $('#opd-section-wrapper');
                container.html(singleMonthHtml);
                
                // Sort data for the table view (descending)
                const sortedTableData = [...dataToDisplay].sort((a,b) => (b[selectedMetric] || 0) - (a[selectedMetric] || 0));
                
                const tableBody = $('#opd-table-body').empty();
                if (sortedTableData.length === 0) {
                    tableBody.html('<tr><td colspan="6" class="text-center text-muted">No data found</td></tr>');
                } else {
                    sortedTableData.forEach(d => {
                        tableBody.append(`<tr><td class="fw-bold">${d.hotel}</td>
                            <td class="text-end">${(d.noOfEmployee || 0).toLocaleString()}</td>
                            <td class="text-end">${(d.medical || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                            <td class="text-end">${(d.dental || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                            <td class="text-end fw-bold">${(d.totalClaims || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                            <td class="text-end">${(d.avgPerHead || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td></tr>`);
                   });
                }
                
                $('#opd-table-title').text(`OPD Data for ${filterPeriod} (${selectedHotel === 'All' ? 'All Hotels' : selectedHotel})`);
                
                // Sort data for the chart view (descending, so highest is at the top in a horizontal bar chart)
                const sortedChartData = [...dataToDisplay].sort((a, b) => (b[selectedMetric] || 0) - (a[selectedMetric] || 0));

                const chartLabels = sortedChartData.map(d => d.hotel);
                const chartData = sortedChartData.map(d => d[selectedMetric] || 0);
                updateBarChart('opd-chart', 'bar', chartLabels, chartData, '#fb6340', 'y');

                $('#opd-chart-title').text(`${metricLabel} for ${filterPeriod} (${selectedHotel === 'All' ? 'All Hotels' : selectedHotel})`);

            } else {
                // RENDER OVERALL MULTI-MONTH VIEW
                 const overallHtml = `
                    <div class="row">
                        <div class="col-12 mb-4">
                            <div class="card"><div class="card-header" id="opd-table-title"></div>
                                <div class="card-body data-table-container"><table class="table table-bordered table-sm">
                                    <thead id="opd-table-head"></thead><tbody id="opd-table-body"></tbody>
                                </table></div>
                            </div>
                        </div>
                        <div class="col-12 mb-4">
                            <div class="card"><div class="card-header" id="opd-chart-title"></div>
                                <div class="card-body"><div class="chart-container" style="height: 500px;"><canvas id="opd-chart"></canvas></div></div>
                            </div>
                        </div>
                    </div>`;
                $('#opd-dynamic-content').html(overallHtml);

                const allPeriods = [...new Set(dataToDisplay.map(d => d.period))].sort((a, b) => parsePeriodToDate(a) - parsePeriodToDate(b));
                const hotelsInSelection = [...new Set(dataToDisplay.map(d => d.hotel))].sort();

                let tableHead = `<tr><th>Month</th>${hotelsInSelection.map(h => `<th>${h}</th>`).join('')}</tr>`;
                $('#opd-table-head').html(tableHead);

                let tableBody = allPeriods.map(p => {
                    let rowHtml = `<tr><td class="text-nowrap" style="background-color: #f8f9fa; color: #212529; font-weight: bold;">${p}</td>`;
                    hotelsInSelection.forEach(h => {
                        const entry = dataToDisplay.find(d => d.period === p && d.hotel === h);
                        const value = entry ? (entry[selectedMetric] || 0) : 0;
                        const displayValue = value > 0 ? value.toLocaleString('en-US', { minimumFractionDigits: selectedMetric === 'noOfEmployee' ? 0 : 2, maximumFractionDigits: 2 }) : '-';
                        rowHtml += `<td style="text-align:center;">${displayValue}</td>`;
                    });
                    return rowHtml + `</tr>`;
                }).join('');
                $('#opd-table-body').html(tableBody);
                $('#opd-table-title').text(`OPD Data Table: ${metricLabel} (${selectedHotel === 'All' ? 'All Hotels' : selectedHotel})`);

                const datasets = hotelsInSelection.map((hotel, index) => ({
                    label: hotel,
                    data: allPeriods.map(p => dataToDisplay.find(d => d.period === p && d.hotel === hotel)?.[selectedMetric] || null),
                    backgroundColor: CHART_COLORS[index % CHART_COLORS.length],
                }));
                updateGroupedBarChart('opd-chart', allPeriods, datasets, {isOpd: true, metric: selectedMetric});
                $('#opd-chart-title').text(`Monthly ${metricLabel} (${selectedHotel === 'All' ? 'All Hotels' : selectedHotel})`);
            }
        }


        // --- CHARTING UTILITIES ---
        
        /**
         * @name numberFormatter
         * @description Formats a number into a shorter string representation (k for thousands, M for millions)
         * by truncating to two decimal places instead of rounding.
         * @param {number} value - The number to format.
         * @returns {string} The formatted number string.
         */
        const numberFormatter = (value) => {
            if (value === null || typeof value === 'undefined') return '';
            
            if (Math.abs(value) >= 1000000) {
                // Truncate to 2 decimal places for millions
                const truncated = Math.floor((value / 1000000) * 100) / 100;
                return truncated.toFixed(2) + 'M';
            }
            if (Math.abs(value) >= 1000) {
                // Truncate to 2 decimal places for thousands
                const truncated = Math.floor((value / 1000) * 100) / 100;
                return truncated.toFixed(2) + 'k';
            }
            // For numbers less than 1000, show with commas and no decimals.
            return value.toLocaleString('en-US', {maximumFractionDigits: 0});
        };

        /**
         * @name updateBarChart
         * @description A central function for creating/updating bar charts.
         */
        function updateBarChart(chartId, type, labels, data, color, axis = 'x') {
            if (chartInstances[chartId]) chartInstances[chartId].destroy();
            const chartContainer = $(`#${chartId}`).parent();
            if (labels.length === 0 || data.every(d => d === 0 || d === null)) {
                chartContainer.html('<div class="d-flex align-items-center justify-content-center h-100 text-muted">No data found</div>');
                return;
            } else {
                chartContainer.html(`<canvas id="${chartId}"></canvas>`);
            }
            
            const ctx = document.getElementById(chartId).getContext('2d');
            
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: axis,
                plugins: {
                    legend: { display: false },
                    datalabels: {
                        display: true,
                        anchor: 'end',
                        align: axis === 'y' ? 'end' : 'top',
                        offset: 4,
                        color: '#495057',
                        font: {
                            weight: 'bold'
                        },
                        formatter: function(value) {
                            if (!value || value === 0) return '';
                            return numberFormatter(value);
                        }
                    }
                },
                scales: {}
            };

            const valueAxisConfig = {
                grid: { display: true },
                ticks: {
                    callback: function(value) {
                        return numberFormatter(value);
                    }
                }
            };

            const categoryAxisConfig = {
                grid: { display: false }
            };

            if (axis === 'y') { // Horizontal chart
                options.scales.x = valueAxisConfig;
                options.scales.y = categoryAxisConfig;
            } else { // Vertical chart ('x')
                options.scales.y = valueAxisConfig;
                options.scales.x = categoryAxisConfig;
            }
            
            chartInstances[chartId] = new Chart(ctx, { 
                type: type, 
                data: { labels, datasets: [{ label: 'Value', data, backgroundColor: color }] }, 
                options: options 
            });
        }

        /**
         * @name updateSimpleBarChartWithPercent
         * @description A function for creating bar charts with percentage formatting.
         */
        function updateSimpleBarChartWithPercent(chartId, type, labels, data, color, axis = 'x') {
            if (chartInstances[chartId]) chartInstances[chartId].destroy();
            const chartContainer = $(`#${chartId}`).parent();
            if(labels.length === 0) { chartContainer.html('<div class="d-flex align-items-center justify-content-center h-100 text-muted">No data found</div>'); return; } 
            else { chartContainer.html(`<canvas id="${chartId}"></canvas>`); }
            
            const ctx = document.getElementById(chartId).getContext('2d');
            const valueAxis = axis === 'y' ? 'x' : 'y';

            chartInstances[chartId] = new Chart(ctx, {
                type: type,
                data: { labels, datasets: [{ label: 'Turnover', data, backgroundColor: color }] },
                options: {
                    responsive: true, maintainAspectRatio: false, indexAxis: axis,
                    plugins: {
                        legend: { display: false },
                        datalabels: { anchor: 'end', align: axis === 'y' ? 'end' : 'top', offset: 4, formatter: v => v.toFixed(1) + '%', color: '#495057' },
                        tooltip: { callbacks: { label: ctx => `${ctx.label}: ${ctx.formattedValue}%` } }
                    },
                    scales: { 
                        [valueAxis]: { beginAtZero: true, ticks: { callback: v => v + '%' } } 
                    }
                }
            });
        }

        /**
         * @name updateGroupedBarChart
         * @description A function for creating grouped bar charts.
         */
        function updateGroupedBarChart(chartId, labels, datasets, formatOptions = {}) {
            if (chartInstances[chartId]) chartInstances[chartId].destroy();
            const chartContainer = $(`#${chartId}`).parent();
            if (datasets.length === 0 || datasets.every(ds => ds.data.every(d => d === null || d === undefined))) {
                chartContainer.html('<div class="d-flex align-items-center justify-content-center h-100 text-muted">No data found for this filter combination.</div>'); return;
            } else { chartContainer.html(`<canvas id="${chartId}"></canvas>`); }
            
            const ctx = document.getElementById(chartId).getContext('2d');
            
            chartInstances[chartId] = new Chart(ctx, {
                type: 'bar', data: { labels, datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top', display: datasets.length > 1 },
                        datalabels: { 
                            display: true,
                            rotation: 0,
                            color: '#495057',
                            font: { size: 9 },
                            align: 'top',
                            anchor: 'end',
                             offset: 4,
                            formatter: (value) => {
                                if (value === null || value === 0) return '';
                                if (formatOptions.isPercentage) {
                                    return value.toFixed(1) + '%';
                                }
                                if (formatOptions.isOpd && formatOptions.metric === 'avgPerHead') {
                                    return value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                                }
                                return numberFormatter(value);
                            }
                        },
                        tooltip: { callbacks: { 
                            label: ctx => {
                                const val = ctx.parsed.y;
                                let label = ctx.dataset.label || '';
                                if (val === null || val === undefined) return `${label}: N/A`;
                                
                                if (formatOptions.isPercentage) {
                                    return `${label}: ${val.toFixed(2)}%`;
                                }
                                // If it's an OPD chart, show the full, locale-formatted number.
                                if (formatOptions.isOpd) {
                                    const fractionDigits = formatOptions.metric === 'avgPerHead' || formatOptions.metric === 'medical' || formatOptions.metric === 'dental' || formatOptions.metric === 'totalClaims' ? 2 : 0;
                                    return `${label}: ${val.toLocaleString('en-US', { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits })}`;
                                }
                                // Fallback for other charts
                                return `${label}: ${numberFormatter(val)}`;
                            }
                        }}
                    },
                    scales: { y: { beginAtZero: true, ticks: { 
                        callback: v => {
                            if (formatOptions.isPercentage) {
                                return v + '%';
                            }
                            return numberFormatter(v);
                        }
                    }}}
                }
            });
        }

        // --- GENERAL UTILITY FUNCTIONS ---
        
        function getColorForValue(value, min, max) {
            if (max === min) return `hsl(120, 70%, 50%)`;
            const ratio = (value - min) / (max - min);
            const hue = ratio * 120; // 0 (red) to 120 (green)
            return `hsl(${hue}, 90%, 45%)`;
        }
        
        function destroyAllCharts() {
            Object.values(chartInstances).forEach(chart => chart.destroy());
            chartInstances = {};
        }
        
        function resetToUpload() {
            destroyAllCharts();
            $('#dashboard-container').hide();
            $('#upload-section').show();
            $('#excel-file-input').val('');
            $('#upload-error').text('');
            allParsedData = []; allTurnoverData = []; allServiceChargeData = []; allOpdData = [];
        }
        
        /**
         * @name formatPeriod
         * @description Parses a cell value into a "Mmm-YY" format. Returns null if invalid.
         */
        function formatPeriod(periodCell) {
            if (periodCell instanceof Date) {
                const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                return `${monthNames[periodCell.getMonth()]}-${String(periodCell.getFullYear()).slice(-2)}`;
            }
            let periodRaw = String(periodCell || '').trim();
            const monthMatch = periodRaw.match(/(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|Nov(ember)?|Dec(ember)?)/i);

            if (monthMatch) {
                const yearMatch = periodRaw.match(/(\d{2,4})/);
                const year = yearMatch ? String(yearMatch[1]).slice(-2) : '25'; // Default to current year '25'
                const month = monthMatch[1].charAt(0).toUpperCase() + monthMatch[1].slice(1, 3).toLowerCase();
                return `${month}-${year}`;
            }
            return null;
        }

        function parsePeriodToDate(periodString) {
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const match = String(periodString || '').match(/^([A-Za-z]{3})-(\d{2})$/);
            if (match) {
                const month = monthNames.findIndex(m => m.toLowerCase() === match[1].toLowerCase());
                if (month !== -1) {
                    let year = parseInt(match[2]);
                    year += (year < 70 ? 2000 : 1900);
                    return new Date(year, month, 1);
                }
            }
            return new Date(0);
        }
    });
    </script>
</body>
</html>
